{
  "provider": "autogen_agentchat.teams.SelectorGroupChat",
  "component_type": "team",
  "version": 1,
  "component_version": 1,
  "description": "A group chat team that have participants takes turn to publish a message\n    to all, using a ChatCompletion model to select the next speaker after each message.",
  "label": "SelectorGroupChat",
  "config": {
    "participants": [
      {
        "provider": "autogen_agentchat.agents.AssistantAgent",
        "component_type": "agent",
        "version": 1,
        "component_version": 1,
        "description": "An agent that provides assistance with tool use.",
        "label": "AssistantAgent",
        "config": {
          "name": "Customer_Verification_agent",
          "model_client": {
            "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
            "component_type": "model",
            "version": 1,
            "component_version": 1,
            "description": "Chat completion client for OpenAI hosted models.",
            "label": "OpenAIChatCompletionClient",
            "config": {
              "response_format": {
                "type": "json_schema",
                "json_schema": {
                  "name": "verification_response",
                  "schema": {
                    "type": "object",
                    "properties": {
                      "verification_result": {
                        "type": "string",
                        "description": "Overall verification outcome",
                        "enum": [
                          "verified",
                          "not_found",
                          "ambiguous"
                        ]
                      },
                      "confidence_percentage": {
                        "type": "integer",
                        "description": "Confidence level in the verification result (0-100)",
                        "minimum": 0,
                        "maximum": 100
                      },
                      "customer_id": {
                        "type": [
                          "string",
                          "null"
                        ],
                        "description": "Customer ID if found, null if not found"
                      },
                      "customer_name": {
                        "type": "string",
                        "description": "Name of the matched customer or requestor name"
                      },
                      "actor": {
                        "type": "string",
                        "description": "Who is making the request",
                        "enum": [
                          "self",
                          "spouse"
                        ]
                      },
                      "match_details": {
                        "type": "string",
                        "description": "Description of what factors contributed to the match"
                      },
                      "search_strategy_used": {
                        "type": "string",
                        "description": "Description of the search approach taken"
                      },
                      "recommendation": {
                        "type": "string",
                        "description": "Recommended next action based on verification quality",
                        "enum": [
                          "Proceed with high confidence",
                          "Manual review recommended",
                          "Additional verification needed"
                        ]
                      }
                    },
                    "required": [
                      "verification_result",
                      "confidence_percentage",
                      "customer_id",
                      "customer_name",
                      "actor",
                      "match_details",
                      "search_strategy_used",
                      "recommendation"
                    ],
                    "additionalProperties": false
                  },
                  "strict": true
                }
              },
              "model": "gpt-4o-mini"
            }
          },
          "workbench": {
            "provider": "autogen_core.tools.StaticWorkbench",
            "component_type": "workbench",
            "version": 1,
            "component_version": 1,
            "description": "A workbench that provides a static set of tools that do not change after\n    each tool execution.",
            "label": "StaticWorkbench",
            "config": {
              "tools": [
                {
                  "provider": "autogen_core.tools.FunctionTool",
                  "component_type": "tool",
                  "version": 1,
                  "component_version": 1,
                  "description": "Create custom tools by wrapping standard Python functions.",
                  "label": "FunctionTool",
                  "config": {
                    "source_code": "def customer_search(ssn: str = \"\", name: str = \"\", address: str = \"\") -> str:\n    \"\"\"\n    Intelligently searches for customers using various criteria with fuzzy matching and confidence scoring.\n\n    Args:\n        ssn (str): The customer's Social Security Number (can be partial, e.g., last 4 digits)\n        name (str): The customer's full name (supports fuzzy matching)\n        address (str): The customer's address (supports partial matching)\n\n    Returns:\n        str: A JSON string containing search results with confidence scores and match details\n    \"\"\"\n    import json\n    import difflib\n\n    def _generate_match_summary(confidence_factors):\n        \"\"\"Generate a human-readable summary of what matched\"\"\"\n        if not confidence_factors:\n            return \"No specific matches found\"\n\n        summaries = [factor[0] for factor in confidence_factors]\n        return \"; \".join(summaries)\n\n    # Mock customers data (loaded from JSON files during team creation)\n    MOCK_CUSTOMERS_DATA = [{'customerId': 'CUST-001', 'fullName': 'Ashlee Thompson', 'dateOfBirth': '1983-01-21', 'ssnLast4': '7583', 'email': 'kayla59@matthews.biz', 'phone': '824.057.7423x6297', 'address': {'street': '5896 Daniel Fort', 'city': 'Joshuahaven', 'state': 'AZ', 'zip': '94396'}, 'militaryStatus': 'Veteran', 'branch': 'Coast Guard', 'serviceStartDate': '2020-01-01', 'serviceEndDate': None}, {'customerId': 'CUST-002', 'fullName': 'Rachel Glover', 'dateOfBirth': '1994-09-19', 'ssnLast4': '8365', 'email': 'mendozanicholas@yahoo.com', 'phone': '824.447.7428x7274', 'address': {'street': '3595 Elizabeth Passage', 'city': 'South Mariaton', 'state': 'OH', 'zip': '59096'}, 'militaryStatus': 'Reserve', 'branch': 'Army', 'serviceStartDate': '2018-10-09', 'serviceEndDate': None}, {'customerId': 'CUST-003', 'fullName': 'Heather Mason', 'dateOfBirth': '1998-05-15', 'ssnLast4': '4674', 'email': 'stephen16@gmail.com', 'phone': '079-991-8795', 'address': {'street': '38232 Joseph Fords', 'city': 'Lake Todd', 'state': 'AZ', 'zip': '58315'}, 'militaryStatus': 'Active Duty', 'branch': 'Army', 'serviceStartDate': '2020-05-17', 'serviceEndDate': None}, {'customerId': 'CUST-004', 'fullName': 'Corey Lucas', 'dateOfBirth': '1993-01-11', 'ssnLast4': '5829', 'email': 'wilsonlisa@williams.info', 'phone': '+1-589-467-8480x428', 'address': {'street': '5266 Shaw Locks', 'city': 'East Melissamouth', 'state': 'MO', 'zip': '35641'}, 'militaryStatus': 'Reserve', 'branch': 'Army', 'serviceStartDate': '2015-03-03', 'serviceEndDate': None}, {'customerId': 'CUST-005', 'fullName': 'Kristopher Phillips', 'dateOfBirth': '1988-03-04', 'ssnLast4': '7025', 'email': 'kellywagner@travis.com', 'phone': '001-161-483-3768x76063', 'address': {'street': '8009 Snyder Radial', 'city': 'East Christyville', 'state': 'KY', 'zip': '48228'}, 'militaryStatus': 'Active Duty', 'branch': 'Marines', 'serviceStartDate': '2014-07-31', 'serviceEndDate': None}]\n\n    customers = MOCK_CUSTOMERS_DATA\n    search_results = []\n\n    for customer in customers:\n        confidence_factors = []\n        total_confidence = 0\n        max_possible_score = 0\n\n        # SSN Matching (highest weight - 40%)\n        if ssn:\n            max_possible_score += 40\n            ssn_clean = ssn.replace(\"-\", \"\").replace(\" \", \"\")\n            customer_ssn = customer.get(\"ssnLast4\", \"\")\n\n            if ssn_clean and customer_ssn:\n                if ssn_clean == customer_ssn:\n                    confidence_factors.append((\"SSN exact match\", 40))\n                    total_confidence += 40\n                elif ssn_clean in customer_ssn or customer_ssn in ssn_clean:\n                    confidence_factors.append((\"SSN partial match\", 25))\n                    total_confidence += 25\n\n        # Name Matching (30% weight)\n        if name:\n            max_possible_score += 30\n            customer_name = customer.get(\"fullName\", \"\").lower()\n            search_name = name.lower()\n\n            if customer_name and search_name:\n                # Exact match\n                if customer_name == search_name:\n                    confidence_factors.append((\"Name exact match\", 30))\n                    total_confidence += 30\n                else:\n                    # Fuzzy matching using difflib\n                    similarity = difflib.SequenceMatcher(None, customer_name, search_name).ratio()\n\n                    if similarity >= 0.9:\n                        score = int(30 * similarity)\n                        confidence_factors.append((f\"Name high similarity ({similarity:.2f})\", score))\n                        total_confidence += score\n                    elif similarity >= 0.7:\n                        score = int(25 * similarity)\n                        confidence_factors.append((f\"Name good similarity ({similarity:.2f})\", score))\n                        total_confidence += score\n                    elif similarity >= 0.5:\n                        score = int(15 * similarity)\n                        confidence_factors.append((f\"Name moderate similarity ({similarity:.2f})\", score))\n                        total_confidence += score\n\n                    # Also check if names contain each other (for partial matches)\n                    name_parts = search_name.split()\n                    customer_parts = customer_name.split()\n                    common_parts = len(set(name_parts) & set(customer_parts))\n                    if common_parts > 0:\n                        part_score = min(15, common_parts * 5)\n                        confidence_factors.append((f\"Name parts match ({common_parts} parts)\", part_score))\n                        total_confidence += part_score\n\n        # Address Matching (30% weight)\n        if address:\n            max_possible_score += 30\n            customer_address = customer.get(\"address\", {})\n            if customer_address:\n                full_customer_address = f\"{customer_address.get('street', '')} {customer_address.get('city', '')} {customer_address.get('state', '')} {customer_address.get('zip', '')}\".lower()\n                search_address = address.lower()\n\n                if search_address in full_customer_address or full_customer_address in search_address:\n                    # Calculate partial match score based on how much of the address matches\n                    if len(search_address) > 0:\n                        match_ratio = min(len(search_address), len(full_customer_address)) / max(len(search_address), len(full_customer_address))\n                        score = int(30 * match_ratio)\n                        confidence_factors.append((f\"Address partial match ({match_ratio:.2f})\", score))\n                        total_confidence += score\n\n                # Check individual components\n                address_components = search_address.split()\n                matched_components = sum(1 for comp in address_components if comp in full_customer_address)\n                if matched_components > 0:\n                    component_score = min(20, matched_components * 5)\n                    confidence_factors.append((f\"Address components match ({matched_components})\", component_score))\n                    total_confidence += component_score\n\n        # Calculate final confidence percentage\n        if max_possible_score > 0:\n            confidence_percentage = min(100, int((total_confidence / max_possible_score) * 100))\n        else:\n            confidence_percentage = 0\n\n        # Only include results with some confidence\n        if confidence_percentage > 0:\n            search_results.append({\n                \"customer\": customer,\n                \"confidence_percentage\": confidence_percentage,\n                \"confidence_factors\": confidence_factors,\n                \"match_summary\": _generate_match_summary(confidence_factors)\n            })\n\n    # Sort by confidence (highest first)\n    search_results.sort(key=lambda x: x[\"confidence_percentage\"], reverse=True)\n\n    # Prepare response\n    response = {\n        \"search_criteria\": {\n            \"ssn\": ssn if ssn else None,\n            \"name\": name if name else None,\n            \"address\": address if address else None\n        },\n        \"total_results\": len(search_results),\n        \"results\": search_results[:5]  # Return top 5 matches\n    }\n\n    return json.dumps(response, indent=2) \n",
                    "name": "customer_search",
                    "description": "Searches for a customer in the System of Record.",
                    "global_imports": [],
                    "has_cancellation_support": false
                  }
                }
              ]
            }
          },
          "model_context": {
            "provider": "autogen_core.model_context.HeadAndTailChatCompletionContext",
            "component_type": "chat_completion_context",
            "version": 1,
            "component_version": 1,
            "description": "A chat completion context that keeps a view of the first n and last m messages,\n    where n is the head size and m is the tail size. The head and tail sizes\n    are set at initialization.",
            "label": "HeadAndTailChatCompletionContext",
            "config": {
              "head_size": 1,
              "tail_size": 3
            }
          },
          "description": "Verifies customer identity and authorization to request benefits",
          "system_message": "You are the Customer Verification Agent responsible for verifying customer identity using multiple data points with intelligent fuzzy matching.\n\n**PRIMARY OBJECTIVE:** Verify the requestor's identity by searching customer records using available information (name, SSN, address, etc.) and determine if they are authorized to make this request.\n\n**SEARCH CAPABILITIES:**\n\n**1. Fuzzy Name Matching:**\n- Uses similarity scoring for partial name matches\n- Handles common variations (nicknames, middle names, etc.)\n- Accounts for potential spelling errors or typos\n\n**2. Partial SSN Support:**\n- Can search with last 4 digits or full SSN\n- Prioritizes full SSN matches but accepts partial matches with other confirmatory data\n\n**3. Address Matching:**\n- Matches individual address components (street, city, state, zip)\n- Supports partial address searches\n- Handles address format variations\n\n**SEARCH STRATEGY SELECTION:**\n\n**If you have full SSN + name:** Use SSN + name combination (highest confidence)\n**If you have partial SSN + name:** Use SSN + name combination \n**If you have name + address:** Use name + address combination\n**If you have only name:** Use name-only search (lowest confidence)\n**If you have only SSN:** Use SSN-only search\n\n**CONFIDENCE ASSESSMENT:**\n\n**HIGH (80-100%):** Exact SSN match + name similarity >90%\n**MEDIUM (60-79%):** SSN partial + good name + address match\n**LOW (40-59%):** Name match + some address components\n**INSUFFICIENT (<40%):** Recommend manual review\n\n**SPOUSE SEARCH CAPABILITY:**\nIf the requestor is not found but mentions being a spouse, search for the service member's name to verify the family connection.\n\n**QUALITY STANDARDS:**\n- Always attempt multiple search strategies if initial search fails\n- Be transparent about match confidence and reasoning\n- Recommend manual review for borderline cases\n- Document specific factors that contributed to confidence score\n- Never make assumptions - only report what the search tools reveal\n\n**CRITICAL**: Only use the customer_search tool. Do not attempt to access customer data directly or make assumptions about customer identity.",
          "model_client_stream": false,
          "reflect_on_tool_use": true,
          "tool_call_summary_format": "{result}",
          "metadata": {}
        }
      },
      {
        "provider": "autogen_agentchat.agents.AssistantAgent",
        "component_type": "agent",
        "version": 1,
        "component_version": 1,
        "description": "An agent that provides assistance with tool use.",
        "label": "AssistantAgent",
        "config": {
          "name": "Document_Processing_agent",
          "model_client": {
            "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
            "component_type": "model",
            "version": 1,
            "component_version": 1,
            "description": "Chat completion client for OpenAI hosted models.",
            "label": "OpenAIChatCompletionClient",
            "config": {
              "model": "gpt-4o-mini"
            }
          },
          "workbench": {
            "provider": "autogen_core.tools.StaticWorkbench",
            "component_type": "workbench",
            "version": 1,
            "component_version": 1,
            "description": "A workbench that provides a static set of tools that do not change after\n    each tool execution.",
            "label": "StaticWorkbench",
            "config": {
              "tools": [
                {
                  "provider": "autogen_core.tools.FunctionTool",
                  "component_type": "tool",
                  "version": 1,
                  "component_version": 1,
                  "description": "Create custom tools by wrapping standard Python functions.",
                  "label": "FunctionTool",
                  "config": {
                    "source_code": "def get_document(request_id: str, document_id: str) -> str:\n    \"\"\"\n    Retrieves a specific document based on request ID and document ID.\n\n    Args:\n        request_id (str): The ID of the benefit request\n        document_id (str): The ID of the specific document to retrieve\n\n    Returns:\n        str: A JSON string containing the document content or an error message\n    \"\"\"\n    import json\n\n    # Mock data (loaded from JSON files during team creation)\n    MOCK_REQUESTS_DATA = [{'requestId': 'REQ-001', 'timestamp': '2025-06-30T21:50:27.064084Z', 'customerId': '', 'requestor': {'fullName': 'Ashlee Thompson', 'dateOfBirth': '1983-01-21', 'ssnLast4': '7583', 'email': 'kayla59@matthews.biz', 'phone': '824.057.7423x6297', 'address': {'street': '5896 Daniel Fort', 'city': 'Joshuahaven', 'state': 'AZ', 'zip': '94396'}, 'militaryStatus': 'Veteran', 'branch': 'Coast Guard', 'serviceStartDate': '2020-01-01', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Auto Loan Deferment', 'description': 'Range next light half ok there.', 'requestedEffectiveDate': '2025-08-06'}, 'documents': [{'documentId': 'DOC-001', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-001.pdf', 'filePath': '/documents/orders_document_DOC-001.pdf'}, {'documentId': 'DOC-002', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-002.pdf', 'filePath': '/documents/proof_of_military_service_DOC-002.pdf'}]}, {'requestId': 'REQ-002', 'timestamp': '2025-06-30T21:50:27.065405Z', 'customerId': '', 'requestor': {'fullName': 'Rachel Glover', 'dateOfBirth': '1994-09-19', 'ssnLast4': '8365', 'email': 'mendozanicholas@yahoo.com', 'phone': '824.447.7428x7274', 'address': {'street': '3595 Elizabeth Passage', 'city': 'South Mariaton', 'state': 'OH', 'zip': '59096'}, 'militaryStatus': 'Reserve', 'branch': 'Army', 'serviceStartDate': '2018-10-09', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Foreclosure Protection', 'description': 'Pass weight culture.', 'requestedEffectiveDate': '2025-07-14'}, 'documents': [{'documentId': 'DOC-003', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-003.pdf', 'filePath': '/documents/proof_of_military_service_DOC-003.pdf'}, {'documentId': 'DOC-004', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-004.pdf', 'filePath': '/documents/orders_document_DOC-004.pdf'}]}, {'requestId': 'REQ-003', 'timestamp': '2025-06-30T21:50:27.066422Z', 'customerId': '', 'requestor': {'fullName': 'Heather Mason', 'dateOfBirth': '1998-05-15', 'ssnLast4': '4674', 'email': 'stephen16@gmail.com', 'phone': '079-991-8795', 'address': {'street': '38232 Joseph Fords', 'city': 'Lake Todd', 'state': 'AZ', 'zip': '58315'}, 'militaryStatus': 'Active Duty', 'branch': 'Army', 'serviceStartDate': '2020-05-17', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Overdraft Fee Refund', 'description': 'Safe become north nice Mr quite enough.', 'requestedEffectiveDate': '2025-08-17'}, 'documents': [{'documentId': 'DOC-005', 'documentType': 'Leave and Earnings Statement', 'fileName': 'leave_and_earnings_statement_DOC-005.pdf', 'filePath': '/documents/leave_and_earnings_statement_DOC-005.pdf'}, {'documentId': 'DOC-006', 'documentType': 'Proof of Residence', 'fileName': 'proof_of_residence_DOC-006.pdf', 'filePath': '/documents/proof_of_residence_DOC-006.pdf'}]}, {'requestId': 'REQ-004', 'timestamp': '2025-06-30T21:50:27.068256Z', 'customerId': '', 'requestor': {'fullName': 'Corey Lucas', 'dateOfBirth': '1993-01-11', 'ssnLast4': '5829', 'email': 'wilsonlisa@williams.info', 'phone': '+1-589-467-8480x428', 'address': {'street': '5266 Shaw Locks', 'city': 'East Melissamouth', 'state': 'MO', 'zip': '35641'}, 'militaryStatus': 'Reserve', 'branch': 'Army', 'serviceStartDate': '2015-03-03', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Foreclosure Protection', 'description': 'Light international so today opportunity.', 'requestedEffectiveDate': '2025-08-19'}, 'documents': [{'documentId': 'DOC-007', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-007.pdf', 'filePath': '/documents/proof_of_military_service_DOC-007.pdf'}, {'documentId': 'DOC-008', 'documentType': 'Proof of Residence', 'fileName': 'proof_of_residence_DOC-008.pdf', 'filePath': '/documents/proof_of_residence_DOC-008.pdf'}]}, {'requestId': 'REQ-005', 'timestamp': '2025-06-30T21:50:27.070075Z', 'customerId': '', 'requestor': {'fullName': 'Kristopher Phillips', 'dateOfBirth': '1988-03-04', 'ssnLast4': '7025', 'email': 'kellywagner@travis.com', 'phone': '001-161-483-3768x76063', 'address': {'street': '8009 Snyder Radial', 'city': 'East Christyville', 'state': 'KY', 'zip': '48228'}, 'militaryStatus': 'Active Duty', 'branch': 'Marines', 'serviceStartDate': '2014-07-31', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Credit Card APR Reduction', 'description': 'Never site national price good design.', 'requestedEffectiveDate': '2025-07-30'}, 'documents': [{'documentId': 'DOC-009', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-009.pdf', 'filePath': '/documents/orders_document_DOC-009.pdf'}, {'documentId': 'DOC-010', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-010.pdf', 'filePath': '/documents/orders_document_DOC-010.pdf'}]}]\n    MOCK_DOCUMENTS_DATA = [{'documentId': 'DOC-001', 'requestId': 'REQ-001', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-001.pdf', 'filePath': '/documents/orders_document_DOC-001.pdf'}, {'documentId': 'DOC-002', 'requestId': 'REQ-001', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-002.pdf', 'filePath': '/documents/proof_of_military_service_DOC-002.pdf'}, {'documentId': 'DOC-003', 'requestId': 'REQ-002', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-003.pdf', 'filePath': '/documents/proof_of_military_service_DOC-003.pdf'}, {'documentId': 'DOC-004', 'requestId': 'REQ-002', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-004.pdf', 'filePath': '/documents/orders_document_DOC-004.pdf'}, {'documentId': 'DOC-005', 'requestId': 'REQ-003', 'documentType': 'Leave and Earnings Statement', 'fileName': 'leave_and_earnings_statement_DOC-005.pdf', 'filePath': '/documents/leave_and_earnings_statement_DOC-005.pdf'}, {'documentId': 'DOC-006', 'requestId': 'REQ-003', 'documentType': 'Proof of Residence', 'fileName': 'proof_of_residence_DOC-006.pdf', 'filePath': '/documents/proof_of_residence_DOC-006.pdf'}, {'documentId': 'DOC-007', 'requestId': 'REQ-004', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-007.pdf', 'filePath': '/documents/proof_of_military_service_DOC-007.pdf'}, {'documentId': 'DOC-008', 'requestId': 'REQ-004', 'documentType': 'Proof of Residence', 'fileName': 'proof_of_residence_DOC-008.pdf', 'filePath': '/documents/proof_of_residence_DOC-008.pdf'}, {'documentId': 'DOC-009', 'requestId': 'REQ-005', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-009.pdf', 'filePath': '/documents/orders_document_DOC-009.pdf'}, {'documentId': 'DOC-010', 'requestId': 'REQ-005', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-010.pdf', 'filePath': '/documents/orders_document_DOC-010.pdf'}]\n\n    def _create_mock_document_content(doc_type: str, request: dict, doc: dict) -> dict:\n        \"\"\"Create realistic mock document content based on document type.\"\"\"\n\n        base_content = {\n            \"document_id\": doc[\"documentId\"],\n            \"file_path\": doc[\"filePath\"],\n            \"processed_date\": \"2024-12-30\"\n        }\n\n        if doc_type == \"Orders Document\":\n            return {\n                **base_content,\n                \"orders_type\": \"Permanent Change of Station (PCS)\",\n                \"effective_date\": request[\"requestDetails\"][\"requestedEffectiveDate\"],\n                \"from_location\": \"Previous Base\",\n                \"to_location\": \"New Assignment Location\",\n                \"report_date\": request[\"requestDetails\"][\"requestedEffectiveDate\"]\n            }\n\n        elif doc_type == \"Proof of Military Service\":\n            return {\n                **base_content,\n                \"service_verification\": True,\n                \"active_duty_status\": \"Active\",\n                \"branch\": \"U.S. Army\",\n                \"rank\": \"Sergeant (E-5)\",\n                \"verification_date\": \"2024-12-30\"\n            }\n\n        elif doc_type == \"Leave and Earnings Statement\":\n            return {\n                **base_content,\n                \"pay_period\": \"2024-12-01 to 2024-12-31\",\n                \"base_pay\": 3500.00,\n                \"allowances\": 1200.00,\n                \"deductions\": 800.00,\n                \"net_pay\": 3900.00\n            }\n\n        elif doc_type == \"Proof of Residence\":\n            return {\n                **base_content,\n                \"address_verified\": True,\n                \"lease_start_date\": \"2024-01-01\",\n                \"monthly_rent\": 2500.00,\n                \"landlord_contact\": \"Property Management Company\"\n            }\n\n        else:\n            return {\n                **base_content,\n                \"content_type\": doc_type,\n                \"status\": \"verified\"\n            }\n\n    # Create a lookup from the mock data with case insensitive keys\n    request_documents = {}\n    request_id_mapping = {}  # Maps lowercase request_id to actual request_id\n\n    # Build document lookup by request_id and document_id (case insensitive)\n    for request in MOCK_REQUESTS_DATA:\n        req_id = request[\"requestId\"]\n        req_id_lower = req_id.lower()\n\n        # Store the mapping from lowercase to actual case\n        request_id_mapping[req_id_lower] = req_id\n\n        if req_id_lower not in request_documents:\n            request_documents[req_id_lower] = {}\n\n        # Also create document_id mapping for case insensitive lookup\n        doc_id_mapping = {}\n\n        for doc in request.get(\"documents\", []):\n            doc_id = doc[\"documentId\"]\n            doc_id_lower = doc_id.lower()\n\n            # Store mapping from lowercase to actual case\n            doc_id_mapping[doc_id_lower] = doc_id\n\n            # Create mock document content based on type\n            mock_content = _create_mock_document_content(doc[\"documentType\"], request, doc)\n            request_documents[req_id_lower][doc_id_lower] = {\n                \"type\": doc[\"documentType\"],\n                \"fileName\": doc[\"fileName\"],\n                \"filePath\": doc[\"filePath\"],\n                \"content\": mock_content,\n                \"actual_document_id\": doc_id  # Store actual case for response\n            }\n\n    # Convert search parameters to lowercase for comparison\n    request_id_lower = request_id.lower()\n    document_id_lower = document_id.lower()\n\n    # Check if request exists (case insensitive)\n    if request_id_lower not in request_documents:\n        available_requests = [request_id_mapping[req_id] for req_id in request_documents.keys()]\n        return json.dumps({\n            \"error\": f\"Request ID '{request_id}' not found\",\n            \"available_requests\": available_requests\n        })\n\n    # Check if document exists for this request (case insensitive)\n    if document_id_lower not in request_documents[request_id_lower]:\n        available_documents = [doc_data[\"actual_document_id\"] for doc_data in request_documents[request_id_lower].values()]\n        return json.dumps({\n            \"error\": f\"Document ID '{document_id}' not found for request '{request_id}'\",\n            \"available_documents\": available_documents\n        })\n\n    # Return the document content\n    document_data = request_documents[request_id_lower][document_id_lower]\n    actual_request_id = request_id_mapping[request_id_lower]\n    actual_document_id = document_data[\"actual_document_id\"]\n\n    return json.dumps({\n        \"request_id\": actual_request_id,\n        \"document_id\": actual_document_id,\n        \"document_type\": document_data[\"type\"],\n        \"file_name\": document_data[\"fileName\"],\n        \"content\": document_data[\"content\"]\n    })\n",
                    "name": "get_document",
                    "description": "Retrieves a specific document based on request ID and document ID.",
                    "global_imports": [],
                    "has_cancellation_support": false
                  }
                }
              ]
            }
          },
          "model_context": {
            "provider": "autogen_core.model_context.UnboundedChatCompletionContext",
            "component_type": "chat_completion_context",
            "version": 1,
            "component_version": 1,
            "description": "An unbounded chat completion context that keeps a view of the all the messages.",
            "label": "UnboundedChatCompletionContext",
            "config": {}
          },
          "description": "Retrieves and processes documents required for benefit decisions",
          "system_message": "You are the Document Processing Agent responsible for retrieving and processing documents needed for benefit eligibility decisions.\n\n**PRIMARY OBJECTIVE:** Retrieve requested documents and provide structured summaries for eligibility assessment.\n\n**DOCUMENT PROCESSING WORKFLOW:**\n\n1. **Document Retrieval**: Use get_document tool with provided document IDs\n2. **Content Analysis**: Review document content for relevant eligibility information\n3. **Information Extraction**: Extract key data points needed for benefit decisions\n4. **Structured Summary**: Provide organized summary for decision-making\n\n**DOCUMENT TYPES AND KEY INFORMATION:**\n\n**Military Orders (DD-1)**\n- Service member name and rank\n- Duty assignment locations\n- Effective dates (start/end)\n- Type of orders (PCS, deployment, training)\n- Special circumstances or restrictions\n\n**Financial Statements**\n- Account balances and transaction history\n- Income verification\n- Debt obligations and payment history\n- Financial hardship indicators\n- Military pay documentation (LES)\n\n**DD-214 (Discharge Papers)**\n- Service dates and duration\n- Discharge type (honorable, general, etc.)\n- Military occupation and training\n- Service-connected disabilities\n- Combat service indicators\n\n**Loan/Credit Documents**\n- Account numbers and current balances\n- Interest rates and terms\n- Payment history and current status\n- Origination dates relative to military service\n- Lender contact information\n\n**Marriage/Family Documents**\n- Marriage certificate with dates\n- Dependent information\n- Family member military status\n- Legal name changes\n\n**Address/Residency Proof**\n- Current and previous addresses\n- Residency verification\n- Utility bills and lease agreements\n- Military housing assignments\n\n**PROCESSING STANDARDS:**\n\n**For Each Document Processed:**\n```\n**Document ID:** [Document ID]\n**Document Type:** [Type of document]\n**Key Information Extracted:**\n- [Specific data point 1]\n- [Specific data point 2]\n- [Additional relevant information]\n\n**Eligibility Relevance:** [How this document supports or challenges eligibility]\n**Verification Status:** [Complete/Incomplete/Requires Additional Information]\n```\n\n**QUALITY ASSURANCE:**\n- Verify document authenticity markers\n- Check for completeness of required information\n- Note any discrepancies or missing data\n- Flag potential fraud indicators\n- Cross-reference information across documents\n\n**FINAL SUMMARY FORMAT:**\n```\n## DOCUMENT PROCESSING SUMMARY\n\n**Documents Processed:** [List of document IDs]\n\n**Eligibility Supporting Evidence:**\n- [Key findings that support benefit eligibility]\n\n**Potential Concerns:**\n- [Any issues, gaps, or discrepancies identified]\n\n**Missing Information:**\n- [Required documents or data not yet provided]\n\n**Recommendation:** [Ready for decision/Need additional documents/Requires manual review]\n```\n\n**CRITICAL INSTRUCTIONS:**\n- Process ALL requested document IDs\n- Extract specific, actionable information\n- Note both supporting and contradicting evidence\n- Flag incomplete or suspicious documents\n- Provide clear, structured summaries for decision-makers\n- Do not make eligibility decisions - only process and summarize documents",
          "model_client_stream": false,
          "reflect_on_tool_use": true,
          "tool_call_summary_format": "{result}",
          "metadata": {}
        }
      },
      {
        "provider": "autogen_agentchat.agents.AssistantAgent",
        "component_type": "agent",
        "version": 1,
        "component_version": 1,
        "description": "An agent that provides assistance with tool use.",
        "label": "AssistantAgent",
        "config": {
          "name": "Eligibility_Decision_agent",
          "model_client": {
            "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
            "component_type": "model",
            "version": 1,
            "component_version": 1,
            "description": "Chat completion client for OpenAI hosted models.",
            "label": "OpenAIChatCompletionClient",
            "config": {
              "model": "gpt-4o-mini"
            }
          },
          "workbench": {
            "provider": "autogen_core.tools.StaticWorkbench",
            "component_type": "workbench",
            "version": 1,
            "component_version": 1,
            "description": "A workbench that provides a static set of tools that do not change after\n    each tool execution.",
            "label": "StaticWorkbench",
            "config": {
              "tools": []
            }
          },
          "model_context": {
            "provider": "autogen_core.model_context.UnboundedChatCompletionContext",
            "component_type": "chat_completion_context",
            "version": 1,
            "component_version": 1,
            "description": "An unbounded chat completion context that keeps a view of the all the messages.",
            "label": "UnboundedChatCompletionContext",
            "config": {}
          },
          "description": "Determines eligibility based on verified context and docs",
          "system_message": "You are the Eligibility Decision Agent responsible for determining benefit eligibility based on industry-standard military/veteran benefit rules.\n\n**ELIGIBILITY FRAMEWORK:**\n\n**1. CORE SERVICE REQUIREMENTS:**\n- **Active Duty**: Currently serving, valid military orders\n- **Veteran**: Honorable discharge required, minimum 24 months service (exceptions for service-connected disabilities)\n- **Reserve/Guard**: Active drilling status, minimum 6 years commitment\n- **Service Verification**: Valid DD-214, orders, or current military ID required\n\n**2. BENEFIT-SPECIFIC ELIGIBILITY RULES:**\n\n**Auto Loan Deferment:**\n- Active duty with PCS orders OR deployment orders\n- Reserve/Guard activated for 180+ days\n- Veterans with documented financial hardship due to service-connected disability\n- Required docs: Orders, loan statements, financial hardship documentation\n- Max deferment: 12 months\n\n**Foreclosure Protection (SCRA):**\n- Active duty with mortgage pre-dating military service OR\n- Active duty with PCS orders affecting ability to sell/rent\n- Reserve/Guard on active duty 30+ days\n- Required docs: Orders, mortgage documents, deployment orders\n- Protection period: Duration of military service + 9 months\n\n**Overdraft Fee Refund:**\n- Active duty members only\n- Fees incurred during deployment or PCS move\n- Must be within 60 days of fee occurrence\n- Required docs: Bank statements, deployment/PCS orders\n- Max refund: $500 per incident\n\n**Credit Card APR Reduction (SCRA):**\n- Active duty with accounts pre-dating military service\n- APR reduction to 6% during active duty\n- Reserve/Guard on orders 30+ days\n- Required docs: Credit statements, military orders, account history\n- Retroactive to start of military service\n\n**3. DISQUALIFYING FACTORS:**\n- Dishonorable discharge\n- Fraudulent documentation\n- Previous benefit abuse/fraud\n- Non-military related financial hardship (for military-specific benefits)\n- Failure to provide required documentation within 30 days\n\n**4. ADDITIONAL CONSIDERATIONS:**\n- **Geographic Requirements**: Some benefits require stateside service\n- **Income Limits**: Financial hardship benefits may have income thresholds\n- **Family Coverage**: Spouse benefits require valid marriage certificate\n- **Emergency Provisions**: Expedited processing for combat deployment\n- **Appeals Process**: All denials subject to 30-day appeal period\n\n**5. DOCUMENTATION MATRIX:**\n- **Identity**: Military ID, DD-214, or current orders\n- **Service Status**: Orders, LES (Leave and Earnings Statement), or command verification\n- **Financial**: Bank statements, loan documents, credit reports\n- **Residence**: Utility bills, lease agreements, PCS orders\n- **Family**: Marriage certificate, dependent ID cards\n\n**DECISION PROCESS:**\n\n1. **Review Available Information**: Check what requestor and document information is available\n2. **Identify Required Documents**: Determine what documents are needed based on benefit type and eligibility rules\n3. **Request Missing Documents**: If critical documents are missing, request them using the REQUEST_PROCESS_DOC format\n4. **Verify Service Status**: Confirm active duty, veteran, or reserve status using available information\n5. **Check Benefit-Specific Rules**: Apply appropriate eligibility criteria\n6. **Document Review**: Ensure all required documentation is present and valid\n7. **Risk Assessment**: Evaluate for fraud indicators or inconsistencies\n8. **Make Decision**: Approve, decline, or request additional information\n\n**USER INPUT HANDLING:**\n\n**For User Disagreement/Corrected Decision:**\nIf you detect a user disagreement or corrected decision (look for \"USER DISAGREEMENT RECORDED\", \"CORRECTED DECISION COLLECTION\", or user's corrected decision):\n- **Apply User's Decision**: Use the user's corrected decision as the final decision\n- **Maintain Quality**: Still provide proper justification and documentation\n- **Note Override**: Clearly indicate this is based on user override\n- **Proceed to Execution**: After applying user's decision, the workflow will proceed to benefit execution\n\n**For Additional User Information/Instructions:**\nIf you detect additional user information or instructions (look for user providing new details, corrections, or specific instructions):\n- **Review New Information**: Carefully consider the additional information provided\n- **Update Assessment**: Revise your eligibility assessment based on new information\n- **Maintain Quality**: Provide proper justification for any changes\n- **Note User Input**: Clearly indicate what information was provided by the user\n- **Proceed to Execution**: After updating the decision, the workflow will proceed to benefit execution\n\n**For User Questions/Clarification Requests:**\nIf you detect user questions or requests for clarification:\n- **Provide Clear Answers**: Answer questions about eligibility rules, requirements, or decision reasoning\n- **Maintain Decision**: Keep the current decision unless new information warrants a change\n- **Proceed to Execution**: After addressing questions, proceed with the current decision\n\n**RESPONSE FORMATS:**\n\n**For missing documents:**\n```json\n{\n  \"action\": \"REQUEST_PROCESS_DOC\",\n  \"docs\": [\"DOC-001\", \"DOC-002\"],\n  \"reason\": \"Need orders and financial statements to verify eligibility\"\n}\n```\n\n**DOCUMENT REQUEST GUIDELINES:**\n\n**When to Request Documents:**\n- If you don't have the specific documents needed for the benefit type\n- If the request mentions documents but you can't see their content\n- If you need to verify specific information (orders, financial statements, etc.)\n\n**How to Request Documents:**\n1. Look at the request details to identify which documents are associated\n2. Use the exact document IDs from the request (e.g., \"DOC-001\", \"DOC-002\")\n3. Provide a clear reason why each document is needed\n4. Use the JSON format above to request document processing\n\n**Common Document Requirements by Benefit Type:**\n- **Auto Loan Deferment**: Orders Document, Proof of Military Service\n- **Foreclosure Protection**: Orders Document, Proof of Military Service  \n- **Overdraft Fee Refund**: Leave and Earnings Statement, Proof of Residence\n- **Credit Card APR Reduction**: Orders Document, Proof of Military Service\n\n**For final decision (always make a decision with available information):**\nUse plain text format instead of JSON to avoid triggering AutoGen's automatic routing:\n\n## ELIGIBILITY DECISION\n\n**Decision:** APPROVED / DECLINED\n\n**Benefit Type:** [Type of benefit]\n\n**Eligibility Basis:** [Reason for decision]\n\n**Justification:** [Detailed explanation of decision reasoning, including all factors considered]\n\n**Conditions:** [Any conditions or requirements if approved]\n\n**Effective Period:** [Time period for benefit if approved]\n\n**Appeal Rights:** Decision may be appealed within 30 days if circumstances change\n\n**Missing Information:** [Note if any critical information was unavailable]\n\n**For user disagreement override:**\n## ELIGIBILITY DECISION (USER OVERRIDE)\n\n**Decision:** APPROVED / DECLINED\n\n**Benefit Type:** [Type of benefit]\n\n**User's Corrected Decision:** [What the user requested]\n\n**Override Basis:** User disagreement with original decision\n\n**Justification:** [Explain the user's reasoning and how it applies to eligibility rules]\n\n**Conditions:** [Any conditions or requirements if approved]\n\n**Effective Period:** [Time period for benefit if approved]\n\n**Note:** This decision is based on user override of the original eligibility assessment\n\n**For additional user information/instructions:**\n## ELIGIBILITY DECISION (UPDATED)\n\n**Decision:** APPROVED / DECLINED\n\n**Benefit Type:** [Type of benefit]\n\n**User's Additional Information:** [What the user provided]\n\n**Updated Basis:** [How the new information affected the decision]\n\n**Justification:** [Explain the updated reasoning based on new information]\n\n**Conditions:** [Any conditions or requirements if approved]\n\n**Effective Period:** [Time period for benefit if approved]\n\n**Note:** This decision was updated based on additional user information\n\n**For user questions/clarification:**\n## ELIGIBILITY DECISION (CLARIFIED)\n\n**Decision:** APPROVED / DECLINED\n\n**Benefit Type:** [Type of benefit]\n\n**User's Questions:** [What the user asked]\n\n**Clarification Provided:** [Answers to user's questions]\n\n**Justification:** [Original decision reasoning]\n\n**Conditions:** [Any conditions or requirements if approved]\n\n**Effective Period:** [Time period for benefit if approved]\n\n**Note:** User questions have been addressed, decision remains unchanged\n\n**CRITICAL**: \n- Use the REQUEST_PROCESS_DOC JSON format when you need documents to make an eligibility decision\n- Do not use REQUEST_USER_INPUT action\n- Always make the best decision possible with available information\n- Use the plain text format for final decisions\n- The Request Analysis Agent will handle workflow routing\n\n**QUALITY STANDARDS:**\n- Always cite specific regulation or policy basis\n- Provide clear, actionable feedback for denials\n- Include appeal information for all decisions\n- Document any exceptions or special circumstances\n- Ensure decisions comply with SCRA, MLA, and DoD regulations\n- Make decisions with available information rather than requesting additional input\n\nDo not invoke follow-up steps — the Orchestrator will handle workflow routing.",
          "model_client_stream": false,
          "reflect_on_tool_use": true,
          "tool_call_summary_format": "{result}",
          "metadata": {}
        }
      },
      {
        "provider": "autogen_agentchat.agents.AssistantAgent",
        "component_type": "agent",
        "version": 1,
        "component_version": 1,
        "description": "An agent that provides assistance with tool use.",
        "label": "AssistantAgent",
        "config": {
          "name": "Request_Analysis_agent",
          "model_client": {
            "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
            "component_type": "model",
            "version": 1,
            "component_version": 1,
            "description": "Chat completion client for OpenAI hosted models.",
            "label": "OpenAIChatCompletionClient",
            "config": {
              "response_format": {
                "type": "json_schema",
                "json_schema": {
                  "name": "routing_response",
                  "schema": {
                    "type": "object",
                    "properties": {
                      "next_agent": {
                        "type": "string",
                        "description": "The exact agent name to route to next, or 'TERMINATE' to end the workflow",
                        "enum": [
                          "Customer_Verification_agent",
                          "Document_Processing_agent",
                          "Eligibility_Decision_agent",
                          "Judge_agent",
                          "User_Proxy_agent",
                          "Benefit_Execution_agent",
                          "TERMINATE"
                        ]
                      },
                      "request_details": {
                        "type": "object",
                        "description": "Request information including requestId and any relevant requestor data",
                        "properties": {
                          "requestId": {
                            "type": "string"
                          },
                          "requestor": {
                            "type": "object",
                            "additionalProperties": false
                          },
                          "requestDetails": {
                            "type": "object",
                            "additionalProperties": false
                          }
                        },
                        "required": [
                          "requestId"
                        ],
                        "additionalProperties": false
                      },
                      "context_summary": {
                        "type": "string",
                        "description": "Brief summary of workflow progress so far"
                      },
                      "instructions": {
                        "type": "string",
                        "description": "Detailed instructions for the next agent"
                      }
                    },
                    "required": [
                      "next_agent",
                      "request_details",
                      "context_summary",
                      "instructions"
                    ],
                    "additionalProperties": false
                  },
                  "strict": true
                }
              },
              "model": "gpt-4o-mini"
            }
          },
          "workbench": {
            "provider": "autogen_core.tools.StaticWorkbench",
            "component_type": "workbench",
            "version": 1,
            "component_version": 1,
            "description": "A workbench that provides a static set of tools that do not change after\n    each tool execution.",
            "label": "StaticWorkbench",
            "config": {
              "tools": [
                {
                  "provider": "autogen_core.tools.FunctionTool",
                  "component_type": "tool",
                  "version": 1,
                  "component_version": 1,
                  "description": "Create custom tools by wrapping standard Python functions.",
                  "label": "FunctionTool",
                  "config": {
                    "source_code": "def get_request_details(request_id: str) -> str:\n    \"\"\"\n    Retrieves the complete details of a benefit request using the request ID.\n\n    Args:\n        request_id (str): The ID of the benefit request to retrieve (e.g., \"REQ-001\")\n\n    Returns:\n        str: A JSON string containing the complete request details including requestor info, \n             benefit type, description, effective date, and associated documents\n    \"\"\"\n    import json\n\n    # Mock requests data (loaded from JSON files during team creation)\n    MOCK_REQUESTS_DATA = [{'requestId': 'REQ-001', 'timestamp': '2025-06-30T21:50:27.064084Z', 'customerId': '', 'requestor': {'fullName': 'Ashlee Thompson', 'dateOfBirth': '1983-01-21', 'ssnLast4': '7583', 'email': 'kayla59@matthews.biz', 'phone': '824.057.7423x6297', 'address': {'street': '5896 Daniel Fort', 'city': 'Joshuahaven', 'state': 'AZ', 'zip': '94396'}, 'militaryStatus': 'Veteran', 'branch': 'Coast Guard', 'serviceStartDate': '2020-01-01', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Auto Loan Deferment', 'description': 'Range next light half ok there.', 'requestedEffectiveDate': '2025-08-06'}, 'documents': [{'documentId': 'DOC-001', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-001.pdf', 'filePath': '/documents/orders_document_DOC-001.pdf'}, {'documentId': 'DOC-002', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-002.pdf', 'filePath': '/documents/proof_of_military_service_DOC-002.pdf'}]}, {'requestId': 'REQ-002', 'timestamp': '2025-06-30T21:50:27.065405Z', 'customerId': '', 'requestor': {'fullName': 'Rachel Glover', 'dateOfBirth': '1994-09-19', 'ssnLast4': '8365', 'email': 'mendozanicholas@yahoo.com', 'phone': '824.447.7428x7274', 'address': {'street': '3595 Elizabeth Passage', 'city': 'South Mariaton', 'state': 'OH', 'zip': '59096'}, 'militaryStatus': 'Reserve', 'branch': 'Army', 'serviceStartDate': '2018-10-09', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Foreclosure Protection', 'description': 'Pass weight culture.', 'requestedEffectiveDate': '2025-07-14'}, 'documents': [{'documentId': 'DOC-003', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-003.pdf', 'filePath': '/documents/proof_of_military_service_DOC-003.pdf'}, {'documentId': 'DOC-004', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-004.pdf', 'filePath': '/documents/orders_document_DOC-004.pdf'}]}, {'requestId': 'REQ-003', 'timestamp': '2025-06-30T21:50:27.066422Z', 'customerId': '', 'requestor': {'fullName': 'Heather Mason', 'dateOfBirth': '1998-05-15', 'ssnLast4': '4674', 'email': 'stephen16@gmail.com', 'phone': '079-991-8795', 'address': {'street': '38232 Joseph Fords', 'city': 'Lake Todd', 'state': 'AZ', 'zip': '58315'}, 'militaryStatus': 'Active Duty', 'branch': 'Army', 'serviceStartDate': '2020-05-17', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Overdraft Fee Refund', 'description': 'Safe become north nice Mr quite enough.', 'requestedEffectiveDate': '2025-08-17'}, 'documents': [{'documentId': 'DOC-005', 'documentType': 'Leave and Earnings Statement', 'fileName': 'leave_and_earnings_statement_DOC-005.pdf', 'filePath': '/documents/leave_and_earnings_statement_DOC-005.pdf'}, {'documentId': 'DOC-006', 'documentType': 'Proof of Residence', 'fileName': 'proof_of_residence_DOC-006.pdf', 'filePath': '/documents/proof_of_residence_DOC-006.pdf'}]}, {'requestId': 'REQ-004', 'timestamp': '2025-06-30T21:50:27.068256Z', 'customerId': '', 'requestor': {'fullName': 'Corey Lucas', 'dateOfBirth': '1993-01-11', 'ssnLast4': '5829', 'email': 'wilsonlisa@williams.info', 'phone': '+1-589-467-8480x428', 'address': {'street': '5266 Shaw Locks', 'city': 'East Melissamouth', 'state': 'MO', 'zip': '35641'}, 'militaryStatus': 'Reserve', 'branch': 'Army', 'serviceStartDate': '2015-03-03', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Foreclosure Protection', 'description': 'Light international so today opportunity.', 'requestedEffectiveDate': '2025-08-19'}, 'documents': [{'documentId': 'DOC-007', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-007.pdf', 'filePath': '/documents/proof_of_military_service_DOC-007.pdf'}, {'documentId': 'DOC-008', 'documentType': 'Proof of Residence', 'fileName': 'proof_of_residence_DOC-008.pdf', 'filePath': '/documents/proof_of_residence_DOC-008.pdf'}]}, {'requestId': 'REQ-005', 'timestamp': '2025-06-30T21:50:27.070075Z', 'customerId': '', 'requestor': {'fullName': 'Kristopher Phillips', 'dateOfBirth': '1988-03-04', 'ssnLast4': '7025', 'email': 'kellywagner@travis.com', 'phone': '001-161-483-3768x76063', 'address': {'street': '8009 Snyder Radial', 'city': 'East Christyville', 'state': 'KY', 'zip': '48228'}, 'militaryStatus': 'Active Duty', 'branch': 'Marines', 'serviceStartDate': '2014-07-31', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Credit Card APR Reduction', 'description': 'Never site national price good design.', 'requestedEffectiveDate': '2025-07-30'}, 'documents': [{'documentId': 'DOC-009', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-009.pdf', 'filePath': '/documents/orders_document_DOC-009.pdf'}, {'documentId': 'DOC-010', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-010.pdf', 'filePath': '/documents/orders_document_DOC-010.pdf'}]}]\n\n    # Search for the request with the matching ID (case insensitive)\n    for request in MOCK_REQUESTS_DATA:\n        stored_id = request.get(\"requestId\", \"\")\n        if stored_id.lower() == request_id.lower():\n            return json.dumps({\n                \"success\": True,\n                \"request\": request\n            }, indent=2)\n\n    # Request not found\n    available_request_ids = [req.get(\"requestId\", \"Unknown\") for req in MOCK_REQUESTS_DATA]\n    return json.dumps({\n        \"success\": False,\n        \"error\": f\"Request ID '{request_id}' not found\",\n        \"available_request_ids\": available_request_ids\n    }, indent=2)\n",
                    "name": "get_request_details",
                    "description": "Retrieves the complete details of a benefit request using the request ID.",
                    "global_imports": [],
                    "has_cancellation_support": false
                  }
                }
              ]
            }
          },
          "model_context": {
            "provider": "autogen_core.model_context.HeadAndTailChatCompletionContext",
            "component_type": "chat_completion_context",
            "version": 1,
            "component_version": 1,
            "description": "A chat completion context that keeps a view of the first n and last m messages,\n    where n is the head size and m is the tail size. The head and tail sizes\n    are set at initialization.",
            "label": "HeadAndTailChatCompletionContext",
            "config": {
              "head_size": 1,
              "tail_size": 3
            }
          },
          "description": "Analyzes request details and applies policy rules to decide next orchestration steps",
          "system_message": "You are the Request Analysis Agent responsible for analyzing workflow context and routing to the next appropriate agent.\n\n**TOOL USAGE RULES:**\n\n1. **CALL `get_request_details` WHEN NEEDED**: You MUST call `get_request_details` if:\n   - User provides a request ID (e.g., \"REQ-001\") AND\n   - You don't have complete request details in the conversation AND\n   - This is the first time you're processing this specific request ID\n\n2. **AVOID DUPLICATE CALLS**: Do NOT call `get_request_details` if:\n   - You have already retrieved details for this exact request ID in this conversation\n   - Another agent has already provided the complete request details\n   - You can see the full request information in recent messages\n\n3. **CHECK CONVERSATION HISTORY**: Before calling the tool, scan recent messages to see if request details are already available\n\n**ROUTING PROCESS:**\n\n1. **CHECK FOR REQUEST ID**: Look for a request ID in the user's message or recent conversation\n2. **RETRIEVE REQUEST DETAILS**: If you find a request ID and don't have the details, call `get_request_details`\n3. **ANALYZE WORKFLOW STATE**: Determine the current stage of the workflow\n4. **ROUTE TO NEXT AGENT**: Apply workflow rules to select the appropriate next agent\n\n**INTELLIGENT USER INPUT ANALYSIS:**\n- Use natural language understanding to interpret user intent\n- Don't rely on specific keywords - understand the meaning and context\n- Consider the user's tone, context, and implied actions\n- Be flexible in interpreting various ways users might express the same intent\n\n**WORKFLOW RULES:**\n\n1. **Initial Step**: If this is the start of a new request (user provides request ID) → First call `get_request_details` to get the request details, then route to Customer_Verification_agent\n\n2. **After Customer Verification**: Always → Eligibility_Decision_agent\n\n3. **Document Request Handling**: If any agent requests documents (REQUEST_PROCESS_DOC) → Document_Processing_agent\n\n4. **After Eligibility Decision**: If you see Eligibility_Decision_agent has provided a decision (containing \"Decision: APPROVED\" or \"Decision: DECLINED\" or \"## ELIGIBILITY DECISION\") → ALWAYS route to Judge_agent\n\n5. **After Judge Agent**: Always → User_Proxy_agent\n\n6. **After User_Proxy_agent**: \n   - If user indicates agreement or approval with the decision → Benefit_Execution_agent\n   - If user indicates disagreement or wants to change the decision → User_Proxy_agent (to collect corrected decision)\n   - If user provides a corrected decision → Eligibility_Decision_agent (to apply user's corrected decision)\n   - If user requests rechecking or reverification of customer information → Customer_Verification_agent\n   - If user requests document review or examination → Document_Processing_agent\n   - If user provides additional information, corrections, or new instructions → Eligibility_Decision_agent (to reconsider with new information)\n   - If user asks questions or requests clarification → Provide helpful response and continue workflow\n\n7. **After Benefit Execution**: If you see Benefit_Execution_agent has provided execution results (containing \"execution_type\", \"status\", or \"TERMINATE\") → ALWAYS route to TERMINATE\n\n**AGENT NAME MAPPING:**\n- Customer Verification → \"Customer_Verification_agent\"\n- Document Processing → \"Document_Processing_agent\"\n- Eligibility Decision → \"Eligibility_Decision_agent\"\n- Judge Agent → \"Judge_agent\"\n- User Input → \"User_Proxy_agent\"\n- Benefit Execution → \"Benefit_Execution_agent\"\n\n**TERMINATION DETECTION:**\n- Look for Benefit_Execution_agent messages containing execution results\n- If execution is complete, route to TERMINATE\n- Do NOT route back to Customer_Verification_agent after benefit execution\n- The workflow ends after benefit execution, not before\n\n**EFFICIENCY PRINCIPLE:**\nPrefer using information already available in the conversation over making new tool calls. Only retrieve request details if they are truly missing from the current context.",
          "model_client_stream": false,
          "reflect_on_tool_use": true,
          "tool_call_summary_format": "{result}",
          "metadata": {}
        }
      },
      {
        "provider": "autogen_agentchat.agents.AssistantAgent",
        "component_type": "agent",
        "version": 1,
        "component_version": 1,
        "description": "An agent that provides assistance with tool use.",
        "label": "AssistantAgent",
        "config": {
          "name": "Benefit_Execution_agent",
          "model_client": {
            "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
            "component_type": "model",
            "version": 1,
            "component_version": 1,
            "description": "Chat completion client for OpenAI hosted models.",
            "label": "OpenAIChatCompletionClient",
            "config": {
              "response_format": {
                "type": "json_schema",
                "json_schema": {
                  "name": "execution_response",
                  "schema": {
                    "type": "object",
                    "properties": {
                      "execution_type": {
                        "type": "string",
                        "description": "Type of execution performed",
                        "enum": [
                          "benefit_activation",
                          "decline_notification"
                        ]
                      },
                      "status": {
                        "type": "string",
                        "description": "Whether the execution was successful",
                        "enum": [
                          "success",
                          "failure"
                        ]
                      },
                      "customer_message": {
                        "type": "string",
                        "description": "Customer-facing message about the outcome"
                      },
                      "details": {
                        "type": "string",
                        "description": "Technical details about the execution or reason for failure"
                      }
                    },
                    "required": [
                      "execution_type",
                      "status",
                      "customer_message",
                      "details"
                    ],
                    "additionalProperties": false
                  },
                  "strict": true
                }
              },
              "model": "gpt-4o-mini"
            }
          },
          "workbench": {
            "provider": "autogen_core.tools.StaticWorkbench",
            "component_type": "workbench",
            "version": 1,
            "component_version": 1,
            "description": "A workbench that provides a static set of tools that do not change after\n    each tool execution.",
            "label": "StaticWorkbench",
            "config": {
              "tools": []
            }
          },
          "model_context": {
            "provider": "autogen_core.model_context.UnboundedChatCompletionContext",
            "component_type": "chat_completion_context",
            "version": 1,
            "component_version": 1,
            "description": "An unbounded chat completion context that keeps a view of the all the messages.",
            "label": "UnboundedChatCompletionContext",
            "config": {}
          },
          "description": "Executes benefit after approval",
          "system_message": "You are the Benefit Execution Agent.\nYou always carry out the final execution step based on the decision made.\n\n**For APPROVED benefits:**\n- Execute the benefit enrollment/activation\n- Generate confirmation details\n- Notify customer of successful activation\n\n**For DECLINED benefits:**\n- Generate decline notification\n- Provide clear explanation of decision\n- Include any appeal/reapplication information",
          "model_client_stream": false,
          "reflect_on_tool_use": true,
          "tool_call_summary_format": "{result}",
          "metadata": {}
        }
      },
      {
        "provider": "autogen_agentchat.agents.AssistantAgent",
        "component_type": "agent",
        "version": 1,
        "component_version": 1,
        "description": "An agent that provides assistance with tool use.",
        "label": "AssistantAgent",
        "config": {
          "name": "Judge_agent",
          "model_client": {
            "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
            "component_type": "model",
            "version": 1,
            "component_version": 1,
            "description": "Chat completion client for OpenAI hosted models.",
            "label": "OpenAIChatCompletionClient",
            "config": {
              "response_format": {
                "type": "json_schema",
                "json_schema": {
                  "name": "quality_assessment",
                  "schema": {
                    "type": "object",
                    "properties": {
                      "quality_score": {
                        "type": "integer",
                        "description": "Overall processing quality score (0-7)",
                        "minimum": 0,
                        "maximum": 7
                      },
                      "workflow_compliance": {
                        "type": "string",
                        "description": "Assessment of adherence to workflow rules",
                        "enum": [
                          "COMPLIANT",
                          "MINOR_DEVIATION",
                          "MAJOR_DEVIATION"
                        ]
                      },
                      "evaluation_summary": {
                        "type": "string",
                        "description": "Overall assessment of processing quality"
                      },
                      "strengths": {
                        "type": "array",
                        "description": "List of what was done well",
                        "items": {
                          "type": "string"
                        }
                      },
                      "concerns": {
                        "type": "array",
                        "description": "List of issues, gaps, or rule violations identified",
                        "items": {
                          "type": "string"
                        }
                      },
                      "recommendation": {
                        "type": "string",
                        "description": "Final recommendation for workflow outcome",
                        "enum": [
                          "PROCEED",
                          "USER_REVIEW_REQUIRED"
                        ]
                      }
                    },
                    "required": [
                      "quality_score",
                      "workflow_compliance",
                      "evaluation_summary",
                      "strengths",
                      "concerns",
                      "recommendation"
                    ],
                    "additionalProperties": false
                  },
                  "strict": true
                }
              },
              "model": "gpt-4o-mini"
            }
          },
          "workbench": {
            "provider": "autogen_core.tools.StaticWorkbench",
            "component_type": "workbench",
            "version": 1,
            "component_version": 1,
            "description": "A workbench that provides a static set of tools that do not change after\n    each tool execution.",
            "label": "StaticWorkbench",
            "config": {
              "tools": []
            }
          },
          "model_context": {
            "provider": "autogen_core.model_context.UnboundedChatCompletionContext",
            "component_type": "chat_completion_context",
            "version": 1,
            "component_version": 1,
            "description": "An unbounded chat completion context that keeps a view of the all the messages.",
            "label": "UnboundedChatCompletionContext",
            "config": {}
          },
          "description": "Monitors orchestration correctness and suggests human review",
          "system_message": "You are the Judge Agent.\nYou review the full conversation history and evaluate the quality of the benefit processing workflow.\n\n**EXPECTED WORKFLOW RULES (from Request Analysis Agent):**\n\n1. **Initial Step**: If this is the start of a new request (user provides request ID) → First call `get_request_details` to get the request details, then route to Customer_Verification_agent\n\n2. **After Customer Verification**: Always → Eligibility_Decision_agent\n\n3. **Document Request Handling**: If any agent requests documents (REQUEST_PROCESS_DOC) → Document_Processing_agent\n\n4. **After Eligibility Decision**: If you see Eligibility_Decision_agent has provided a decision (containing \"Decision: APPROVED\" or \"Decision: DECLINED\" or \"## ELIGIBILITY DECISION\") → ALWAYS route to Judge_agent\n\n5. **After Judge Agent**: Always → User_Proxy_agent\n\n6. **After User_Proxy_agent**: If user agrees with decision → Benefit_Execution_agent\n\n7. **After Benefit Execution**: If you see Benefit_Execution_agent has provided execution results (containing \"execution_type\", \"status\", or \"TERMINATE\") → ALWAYS route to TERMINATE\n\n**AGENT NAME MAPPING:**\n- Customer Verification → \"Customer_Verification_agent\"\n- Document Processing → \"Document_Processing_agent\"\n- Eligibility Decision → \"Eligibility_Decision_agent\"\n- Judge Agent → \"Judge_agent\"\n- User Input → \"User_Proxy_agent\"\n- Benefit Execution → \"Benefit_Execution_agent\"\n\n**TERMINATION DETECTION:**\n- Look for Benefit_Execution_agent messages containing execution results\n- If execution is complete, route to TERMINATE\n- Do NOT route back to Customer_Verification_agent after benefit execution\n- The workflow ends after benefit execution, not before\n\n**Your Task:**\n1. **Review Complete Conversation**: Analyze the full conversation from start to current point\n2. **Evaluate Workflow Compliance**: Check if agents followed the exact workflow rules above\n3. **Assess Tool Usage**: Verify Request Analysis Agent properly used `get_request_details` when needed\n4. **Check Agent Sequence**: Ensure agents were called in the correct order according to workflow rules\n5. **Verify Document Handling**: Confirm document requests were properly routed through Document Processing Agent\n6. **Assess Decision Quality**: Evaluate the quality of customer verification, eligibility decisions, and benefit execution\n7. **Check Termination Logic**: Verify the workflow properly terminated after benefit execution\n8. **Identify Rule Violations**: Flag any deviations from the expected workflow sequence\n\n**Scoring Guide:**\n\n**Score 7 (Perfect Execution):**\n- All workflow steps completed in correct sequence\n- Request Analysis Agent properly retrieved request details when needed\n- Document requests properly routed through Document Processing Agent\n- All agents provided high-quality outputs\n- Workflow terminated correctly after benefit execution\n\n**Score 6 (Good Execution):**\n- Minor deviations from workflow rules\n- Small issues with tool usage or agent sequencing\n- Overall quality maintained with minor concerns\n\n**Score 5-4 (Adequate Execution):**\n- Notable deviations from workflow rules\n- Issues with agent sequencing or tool usage\n- Quality concerns in some agent outputs\n- May have skipped or duplicated steps\n\n**Score 3-0 (Poor Execution):**\n- Major rule violations or workflow deviations\n- Significant issues with agent sequencing\n- Poor quality outputs from multiple agents\n- Missing critical steps or improper termination\n\n**If score < 6, set recommendation to USER_REVIEW_REQUIRED**",
          "model_client_stream": false,
          "reflect_on_tool_use": true,
          "tool_call_summary_format": "{result}",
          "metadata": {}
        }
      },
      {
        "provider": "autogen_agentchat.agents.UserProxyAgent",
        "component_type": "agent",
        "version": 1,
        "component_version": 1,
        "description": "An agent that can represent a human user through an input function.",
        "label": "UserProxyAgent",
        "config": {
          "name": "User_Proxy_agent",
          "description": "Handles user questions, uploads, and final approval"
        }
      }
    ],
    "model_client": {
      "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
      "component_type": "model",
      "version": 1,
      "component_version": 1,
      "description": "Chat completion client for OpenAI hosted models.",
      "label": "OpenAIChatCompletionClient",
      "config": {
        "model": "gpt-4o-mini"
      }
    },
    "termination_condition": {
      "provider": "autogen_agentchat.conditions.TextMentionTermination",
      "component_type": "termination",
      "version": 1,
      "component_version": 1,
      "description": "Terminate the conversation if a specific text is mentioned.",
      "label": "TextMentionTermination",
      "config": {
        "text": "TERMINATE"
      }
    },
    "selector_prompt": "STEP 1: Look at the conversation below and find the VERY LAST speaker (scan from bottom up, find the final agent name before a colon).\n\nSTEP 2: Apply these rules:\n- If the final speaker was NOT 'Request_Analysis_agent' → return 'Request_Analysis_agent'\n- If the final speaker WAS 'Request_Analysis_agent' → look for 'next_agent' in their JSON response and return that agent name\n\n<CONVERSATION_HISTORY>\n{history}\n</CONVERSATION_HISTORY>\n\nRead the above history and find the final speaker. Apply the rules. Return ONLY the agent name:",
    "allow_repeated_speaker": false,
    "max_selector_attempts": 3,
    "emit_team_events": false,
    "model_client_streaming": false,
    "model_context": {
      "provider": "autogen_core.model_context.HeadAndTailChatCompletionContext",
      "component_type": "chat_completion_context",
      "version": 1,
      "component_version": 1,
      "description": "A chat completion context that keeps a view of the first n and last m messages,\n    where n is the head size and m is the tail size. The head and tail sizes\n    are set at initialization.",
      "label": "HeadAndTailChatCompletionContext",
      "config": {
        "head_size": 1,
        "tail_size": 2
      }
    }
  }
}