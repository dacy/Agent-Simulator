{
  "provider": "autogen_agentchat.teams.SelectorGroupChat",
  "component_type": "team",
  "version": 1,
  "component_version": 1,
  "label": "Benefit Orchestrator",
  "config": {
    "participants": [
      {
        "provider": "autogen_agentchat.agents.AssistantAgent",
        "component_type": "agent",
        "version": 1,
        "component_version": 1,
        "label": "Customer Verification",
        "config": {
          "name": "Customer_Verification_agent",
          "description": "Looks up requester to see if they are a customer",
          "model_client": {
            "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
            "config": {
              "model": "gpt-4o-mini"
            },
            "component_type": "model",
            "version": 1,
            "component_version": 1,
            "description": "Chat completion client for OpenAI hosted models.",
            "label": "OpenAIChatCompletionClient"
          },
          "model_context": {
            "provider": "autogen_core.model_context.UnboundedChatCompletionContext",
            "config": {},
            "component_type": "chat_completion_context",
            "version": 1,
            "component_version": 1,
            "description": "An unbounded chat completion context that keeps a view of the all the messages.",
            "label": "UnboundedChatCompletionContext"
          },
          "system_message": "You are the Customer Verification Agent.\nYour job is to intelligently verify whether the requester (or their spouse) exists in the System of Record (SOR) using advanced fuzzy search capabilities.\n\n**SEARCH STRATEGY:**\nYou have access to the `customer_search` tool that supports:\n- **SSN matching** (exact or partial, highest confidence weight)\n- **Name matching** (exact, fuzzy, and partial word matching)\n- **Address matching** (partial and component-based matching)\n- **Confidence scoring** (percentage-based with detailed factors)\n\n**DECISION LOGIC:**\nUse your best judgment to determine the optimal search strategy:\n\n1. **Primary Search**: Use the most reliable data available:\n   - If SSN (full or last 4) is available \u2192 Start with SSN-based search\n   - If no SSN \u2192 Use name + address combination\n   - If only name \u2192 Use name-only search with fuzzy matching\n\n2. **Fuzzy Matching**: The tool handles misspellings and variations:\n   - Names with typos (uses similarity algorithms)\n   - Partial addresses or different formatting\n   - Missing or swapped name components\n\n3. **Confidence Assessment**:\n   - **90-100%**: High confidence, likely correct match\n   - **70-89%**: Good confidence, probably correct with minor discrepancies\n   - **50-69%**: Moderate confidence, requires careful evaluation\n   - **Below 50%**: Low confidence, may need additional verification\n\n4. **Multi-Criteria Search**: If initial search yields low confidence:\n   - Try different combinations of available data\n   - Search for spouse if requester not found\n   - Consider variations in name spelling or format\n\n**OUTPUT FORMAT:**\n```json\n{\n  \"verification_result\": \"verified\" | \"not_found\" | \"ambiguous\",\n  \"confidence_percentage\": 85,\n  \"customer_id\": \"CUST-12345\" | null,\n  \"customer_name\": \"John Doe\",\n  \"actor\": \"self\" | \"spouse\",\n  \"match_details\": \"SSN exact match; Name exact match\",\n  \"search_strategy_used\": \"SSN + Name combination\",\n  \"recommendation\": \"Proceed with high confidence\" | \"Manual review recommended\" | \"Additional verification needed\"\n}\n```\n\n**DECISION RULES:**\n- **Verified**: Confidence \u2265 70% with clear primary identifier match\n- **Ambiguous**: Multiple matches or confidence 50-69%\n- **Not Found**: No matches or all matches below 50% confidence\n\n**QUALITY STANDARDS:**\n- Always explain your reasoning and confidence factors\n- If multiple potential matches, present the top candidates\n- Suggest additional search strategies if initial attempts are inconclusive\n- Be transparent about uncertainty and recommend manual review when appropriate",
          "reflect_on_tool_use": true,
          "model_client_stream": false,
          "tool_call_summary_format": "{result}",
          "tools": [
            {
              "provider": "autogen_core.tools.FunctionTool",
              "component_type": "tool",
              "version": 1,
              "component_version": 1,
              "description": "Searches for a customer in the System of Record.",
              "label": "Customer Search Tool",
              "config": {
                "name": "customer_search",
                "description": "Looks up a customer based on identifying information.",
                "source_code": "import json\nimport difflib\nfrom typing import Dict, List, Tuple\n\ndef customer_search(ssn: str = \"\", name: str = \"\", address: str = \"\") -> str:\n    \"\"\"\n    Intelligently searches for customers using various criteria with fuzzy matching and confidence scoring.\n    \n    Args:\n        ssn (str): The customer's Social Security Number (can be partial, e.g., last 4 digits)\n        name (str): The customer's full name (supports fuzzy matching)\n        address (str): The customer's address (supports partial matching)\n    \n    Returns:\n        str: A JSON string containing search results with confidence scores and match details\n    \"\"\"\n    \n    # This will be replaced with actual mock data by combine_tools.py\n    MOCK_CUSTOMERS_DATA = [{'customerId': 'CUST-001', 'fullName': 'Ashlee Thompson', 'dateOfBirth': '1983-01-21', 'ssnLast4': '7583', 'email': 'kayla59@matthews.biz', 'phone': '824.057.7423x6297', 'address': {'street': '5896 Daniel Fort', 'city': 'Joshuahaven', 'state': 'AZ', 'zip': '94396'}, 'militaryStatus': 'Veteran', 'branch': 'Coast Guard', 'serviceStartDate': '2020-01-01', 'serviceEndDate': None}, {'customerId': 'CUST-002', 'fullName': 'Rachel Glover', 'dateOfBirth': '1994-09-19', 'ssnLast4': '8365', 'email': 'mendozanicholas@yahoo.com', 'phone': '824.447.7428x7274', 'address': {'street': '3595 Elizabeth Passage', 'city': 'South Mariaton', 'state': 'OH', 'zip': '59096'}, 'militaryStatus': 'Reserve', 'branch': 'Army', 'serviceStartDate': '2018-10-09', 'serviceEndDate': None}, {'customerId': 'CUST-003', 'fullName': 'Heather Mason', 'dateOfBirth': '1998-05-15', 'ssnLast4': '4674', 'email': 'stephen16@gmail.com', 'phone': '079-991-8795', 'address': {'street': '38232 Joseph Fords', 'city': 'Lake Todd', 'state': 'AZ', 'zip': '58315'}, 'militaryStatus': 'Active Duty', 'branch': 'Army', 'serviceStartDate': '2020-05-17', 'serviceEndDate': None}, {'customerId': 'CUST-004', 'fullName': 'Corey Lucas', 'dateOfBirth': '1993-01-11', 'ssnLast4': '5829', 'email': 'wilsonlisa@williams.info', 'phone': '+1-589-467-8480x428', 'address': {'street': '5266 Shaw Locks', 'city': 'East Melissamouth', 'state': 'MO', 'zip': '35641'}, 'militaryStatus': 'Reserve', 'branch': 'Army', 'serviceStartDate': '2015-03-03', 'serviceEndDate': None}, {'customerId': 'CUST-005', 'fullName': 'Kristopher Phillips', 'dateOfBirth': '1988-03-04', 'ssnLast4': '7025', 'email': 'kellywagner@travis.com', 'phone': '001-161-483-3768x76063', 'address': {'street': '8009 Snyder Radial', 'city': 'East Christyville', 'state': 'KY', 'zip': '48228'}, 'militaryStatus': 'Active Duty', 'branch': 'Marines', 'serviceStartDate': '2014-07-31', 'serviceEndDate': None}]\n    \n    customers = MOCK_CUSTOMERS_DATA\n    search_results = []\n    \n    for customer in customers:\n        confidence_factors = []\n        total_confidence = 0\n        max_possible_score = 0\n        \n        # SSN Matching (highest weight - 40%)\n        if ssn:\n            max_possible_score += 40\n            ssn_clean = ssn.replace(\"-\", \"\").replace(\" \", \"\")\n            customer_ssn = customer.get(\"ssnLast4\", \"\")\n            \n            if ssn_clean and customer_ssn:\n                if ssn_clean == customer_ssn:\n                    confidence_factors.append((\"SSN exact match\", 40))\n                    total_confidence += 40\n                elif ssn_clean in customer_ssn or customer_ssn in ssn_clean:\n                    confidence_factors.append((\"SSN partial match\", 25))\n                    total_confidence += 25\n        \n        # Name Matching (30% weight)\n        if name:\n            max_possible_score += 30\n            customer_name = customer.get(\"fullName\", \"\").lower()\n            search_name = name.lower()\n            \n            if customer_name and search_name:\n                # Exact match\n                if customer_name == search_name:\n                    confidence_factors.append((\"Name exact match\", 30))\n                    total_confidence += 30\n                else:\n                    # Fuzzy matching using difflib\n                    similarity = difflib.SequenceMatcher(None, customer_name, search_name).ratio()\n                    \n                    if similarity >= 0.9:\n                        score = int(30 * similarity)\n                        confidence_factors.append((f\"Name high similarity ({similarity:.2f})\", score))\n                        total_confidence += score\n                    elif similarity >= 0.7:\n                        score = int(25 * similarity)\n                        confidence_factors.append((f\"Name good similarity ({similarity:.2f})\", score))\n                        total_confidence += score\n                    elif similarity >= 0.5:\n                        score = int(15 * similarity)\n                        confidence_factors.append((f\"Name moderate similarity ({similarity:.2f})\", score))\n                        total_confidence += score\n                    \n                    # Also check if names contain each other (for partial matches)\n                    name_parts = search_name.split()\n                    customer_parts = customer_name.split()\n                    common_parts = len(set(name_parts) & set(customer_parts))\n                    if common_parts > 0:\n                        part_score = min(15, common_parts * 5)\n                        confidence_factors.append((f\"Name parts match ({common_parts} parts)\", part_score))\n                        total_confidence += part_score\n        \n        # Address Matching (30% weight)\n        if address:\n            max_possible_score += 30\n            customer_address = customer.get(\"address\", {})\n            if customer_address:\n                full_customer_address = f\"{customer_address.get('street', '')} {customer_address.get('city', '')} {customer_address.get('state', '')} {customer_address.get('zip', '')}\".lower()\n                search_address = address.lower()\n                \n                if search_address in full_customer_address or full_customer_address in search_address:\n                    # Calculate partial match score based on how much of the address matches\n                    if len(search_address) > 0:\n                        match_ratio = min(len(search_address), len(full_customer_address)) / max(len(search_address), len(full_customer_address))\n                        score = int(30 * match_ratio)\n                        confidence_factors.append((f\"Address partial match ({match_ratio:.2f})\", score))\n                        total_confidence += score\n                \n                # Check individual components\n                address_components = search_address.split()\n                matched_components = sum(1 for comp in address_components if comp in full_customer_address)\n                if matched_components > 0:\n                    component_score = min(20, matched_components * 5)\n                    confidence_factors.append((f\"Address components match ({matched_components})\", component_score))\n                    total_confidence += component_score\n        \n        # Calculate final confidence percentage\n        if max_possible_score > 0:\n            confidence_percentage = min(100, int((total_confidence / max_possible_score) * 100))\n        else:\n            confidence_percentage = 0\n        \n        # Only include results with some confidence\n        if confidence_percentage > 0:\n            search_results.append({\n                \"customer\": customer,\n                \"confidence_percentage\": confidence_percentage,\n                \"confidence_factors\": confidence_factors,\n                \"match_summary\": _generate_match_summary(confidence_factors)\n            })\n    \n    # Sort by confidence (highest first)\n    search_results.sort(key=lambda x: x[\"confidence_percentage\"], reverse=True)\n    \n    # Prepare response\n    response = {\n        \"search_criteria\": {\n            \"ssn\": ssn if ssn else None,\n            \"name\": name if name else None,\n            \"address\": address if address else None\n        },\n        \"total_results\": len(search_results),\n        \"results\": search_results[:5]  # Return top 5 matches\n    }\n    \n    return json.dumps(response, indent=2)\n\ndef _generate_match_summary(confidence_factors: List[Tuple[str, int]]) -> str:\n    \"\"\"Generate a human-readable summary of what matched\"\"\"\n    if not confidence_factors:\n        return \"No specific matches found\"\n    \n    summaries = [factor[0] for factor in confidence_factors]\n    return \"; \".join(summaries) ",
                "global_imports": [],
                "has_cancellation_support": false
              }
            }
          ],
          "metadata": {}
        },
        "description": "Looks up requester to see if they are a customer"
      },
      {
        "provider": "autogen_agentchat.agents.AssistantAgent",
        "component_type": "agent",
        "version": 1,
        "component_version": 1,
        "label": "Document Processing",
        "config": {
          "name": "Document_Processing_agent",
          "description": "Processes document requests and returns specific document content",
          "model_client": {
            "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
            "config": {
              "model": "gpt-4o-mini"
            },
            "component_type": "model",
            "version": 1,
            "component_version": 1,
            "description": "Chat completion client for OpenAI hosted models.",
            "label": "OpenAIChatCompletionClient"
          },
          "model_context": {
            "provider": "autogen_core.model_context.UnboundedChatCompletionContext",
            "config": {},
            "component_type": "chat_completion_context",
            "version": 1,
            "component_version": 1,
            "description": "An unbounded chat completion context that keeps a view of the all the messages.",
            "label": "UnboundedChatCompletionContext"
          },
          "system_message": "You are the Document Processing Agent. Your job is to process document requests and return the specific content of requested documents.\n\nWhen you receive a document request:\n1. Use the `get_document` tool with the provided request_id and document_id\n2. Return the document content in a clear, structured format\n3. If the document is not found, provide an appropriate error message\n\nAlways provide complete and accurate document information to support the benefit processing workflow.",
          "reflect_on_tool_use": true,
          "model_client_stream": false,
          "tool_call_summary_format": "{result}",
          "tools": [
            {
              "provider": "autogen_core.tools.FunctionTool",
              "component_type": "tool",
              "version": 1,
              "component_version": 1,
              "label": "Get Document Tool",
              "config": {
                "name": "get_document",
                "description": "Retrieves a specific document based on request ID and document ID.",
                "source_code": "import json\n\ndef get_document(request_id: str, document_id: str) -> str:\n    \"\"\"\n    Retrieves a specific document based on request ID and document ID.\n    \n    Args:\n        request_id (str): The ID of the benefit request\n        document_id (str): The ID of the specific document to retrieve\n        \n    Returns:\n        str: A JSON string containing the document content or an error message\n    \"\"\"\n    # These will be replaced with actual mock data by combine_tools.py\n    MOCK_REQUESTS_DATA = [{'requestId': 'REQ-001', 'timestamp': '2025-06-30T21:50:27.064084Z', 'customerId': '', 'requestor': {'fullName': 'Ashlee Thompson', 'dateOfBirth': '1983-01-21', 'ssnLast4': '7583', 'email': 'kayla59@matthews.biz', 'phone': '824.057.7423x6297', 'address': {'street': '5896 Daniel Fort', 'city': 'Joshuahaven', 'state': 'AZ', 'zip': '94396'}, 'militaryStatus': 'Veteran', 'branch': 'Coast Guard', 'serviceStartDate': '2020-01-01', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Auto Loan Deferment', 'description': 'Range next light half ok there.', 'requestedEffectiveDate': '2025-08-06'}, 'documents': [{'documentId': 'DOC-001', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-001.pdf', 'filePath': '/documents/orders_document_DOC-001.pdf'}, {'documentId': 'DOC-002', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-002.pdf', 'filePath': '/documents/proof_of_military_service_DOC-002.pdf'}]}, {'requestId': 'REQ-002', 'timestamp': '2025-06-30T21:50:27.065405Z', 'customerId': '', 'requestor': {'fullName': 'Rachel Glover', 'dateOfBirth': '1994-09-19', 'ssnLast4': '8365', 'email': 'mendozanicholas@yahoo.com', 'phone': '824.447.7428x7274', 'address': {'street': '3595 Elizabeth Passage', 'city': 'South Mariaton', 'state': 'OH', 'zip': '59096'}, 'militaryStatus': 'Reserve', 'branch': 'Army', 'serviceStartDate': '2018-10-09', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Foreclosure Protection', 'description': 'Pass weight culture.', 'requestedEffectiveDate': '2025-07-14'}, 'documents': [{'documentId': 'DOC-003', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-003.pdf', 'filePath': '/documents/proof_of_military_service_DOC-003.pdf'}, {'documentId': 'DOC-004', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-004.pdf', 'filePath': '/documents/orders_document_DOC-004.pdf'}]}, {'requestId': 'REQ-003', 'timestamp': '2025-06-30T21:50:27.066422Z', 'customerId': '', 'requestor': {'fullName': 'Heather Mason', 'dateOfBirth': '1998-05-15', 'ssnLast4': '4674', 'email': 'stephen16@gmail.com', 'phone': '079-991-8795', 'address': {'street': '38232 Joseph Fords', 'city': 'Lake Todd', 'state': 'AZ', 'zip': '58315'}, 'militaryStatus': 'Active Duty', 'branch': 'Army', 'serviceStartDate': '2020-05-17', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Overdraft Fee Refund', 'description': 'Safe become north nice Mr quite enough.', 'requestedEffectiveDate': '2025-08-17'}, 'documents': [{'documentId': 'DOC-005', 'documentType': 'Leave and Earnings Statement', 'fileName': 'leave_and_earnings_statement_DOC-005.pdf', 'filePath': '/documents/leave_and_earnings_statement_DOC-005.pdf'}, {'documentId': 'DOC-006', 'documentType': 'Proof of Residence', 'fileName': 'proof_of_residence_DOC-006.pdf', 'filePath': '/documents/proof_of_residence_DOC-006.pdf'}]}, {'requestId': 'REQ-004', 'timestamp': '2025-06-30T21:50:27.068256Z', 'customerId': '', 'requestor': {'fullName': 'Corey Lucas', 'dateOfBirth': '1993-01-11', 'ssnLast4': '5829', 'email': 'wilsonlisa@williams.info', 'phone': '+1-589-467-8480x428', 'address': {'street': '5266 Shaw Locks', 'city': 'East Melissamouth', 'state': 'MO', 'zip': '35641'}, 'militaryStatus': 'Reserve', 'branch': 'Army', 'serviceStartDate': '2015-03-03', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Foreclosure Protection', 'description': 'Light international so today opportunity.', 'requestedEffectiveDate': '2025-08-19'}, 'documents': [{'documentId': 'DOC-007', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-007.pdf', 'filePath': '/documents/proof_of_military_service_DOC-007.pdf'}, {'documentId': 'DOC-008', 'documentType': 'Proof of Residence', 'fileName': 'proof_of_residence_DOC-008.pdf', 'filePath': '/documents/proof_of_residence_DOC-008.pdf'}]}, {'requestId': 'REQ-005', 'timestamp': '2025-06-30T21:50:27.070075Z', 'customerId': '', 'requestor': {'fullName': 'Kristopher Phillips', 'dateOfBirth': '1988-03-04', 'ssnLast4': '7025', 'email': 'kellywagner@travis.com', 'phone': '001-161-483-3768x76063', 'address': {'street': '8009 Snyder Radial', 'city': 'East Christyville', 'state': 'KY', 'zip': '48228'}, 'militaryStatus': 'Active Duty', 'branch': 'Marines', 'serviceStartDate': '2014-07-31', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Credit Card APR Reduction', 'description': 'Never site national price good design.', 'requestedEffectiveDate': '2025-07-30'}, 'documents': [{'documentId': 'DOC-009', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-009.pdf', 'filePath': '/documents/orders_document_DOC-009.pdf'}, {'documentId': 'DOC-010', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-010.pdf', 'filePath': '/documents/orders_document_DOC-010.pdf'}]}]\n    MOCK_DOCUMENTS_DATA = [{'documentId': 'DOC-001', 'requestId': 'REQ-001', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-001.pdf', 'filePath': '/documents/orders_document_DOC-001.pdf'}, {'documentId': 'DOC-002', 'requestId': 'REQ-001', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-002.pdf', 'filePath': '/documents/proof_of_military_service_DOC-002.pdf'}, {'documentId': 'DOC-003', 'requestId': 'REQ-002', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-003.pdf', 'filePath': '/documents/proof_of_military_service_DOC-003.pdf'}, {'documentId': 'DOC-004', 'requestId': 'REQ-002', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-004.pdf', 'filePath': '/documents/orders_document_DOC-004.pdf'}, {'documentId': 'DOC-005', 'requestId': 'REQ-003', 'documentType': 'Leave and Earnings Statement', 'fileName': 'leave_and_earnings_statement_DOC-005.pdf', 'filePath': '/documents/leave_and_earnings_statement_DOC-005.pdf'}, {'documentId': 'DOC-006', 'requestId': 'REQ-003', 'documentType': 'Proof of Residence', 'fileName': 'proof_of_residence_DOC-006.pdf', 'filePath': '/documents/proof_of_residence_DOC-006.pdf'}, {'documentId': 'DOC-007', 'requestId': 'REQ-004', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-007.pdf', 'filePath': '/documents/proof_of_military_service_DOC-007.pdf'}, {'documentId': 'DOC-008', 'requestId': 'REQ-004', 'documentType': 'Proof of Residence', 'fileName': 'proof_of_residence_DOC-008.pdf', 'filePath': '/documents/proof_of_residence_DOC-008.pdf'}, {'documentId': 'DOC-009', 'requestId': 'REQ-005', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-009.pdf', 'filePath': '/documents/orders_document_DOC-009.pdf'}, {'documentId': 'DOC-010', 'requestId': 'REQ-005', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-010.pdf', 'filePath': '/documents/orders_document_DOC-010.pdf'}]\n    \n    # Create a lookup from the mock data with case insensitive keys\n    request_documents = {}\n    request_id_mapping = {}  # Maps lowercase request_id to actual request_id\n    \n    # Build document lookup by request_id and document_id (case insensitive)\n    for request in MOCK_REQUESTS_DATA:\n        req_id = request[\"requestId\"]\n        req_id_lower = req_id.lower()\n        \n        # Store the mapping from lowercase to actual case\n        request_id_mapping[req_id_lower] = req_id\n        \n        if req_id_lower not in request_documents:\n            request_documents[req_id_lower] = {}\n        \n        # Also create document_id mapping for case insensitive lookup\n        doc_id_mapping = {}\n        \n        for doc in request.get(\"documents\", []):\n            doc_id = doc[\"documentId\"]\n            doc_id_lower = doc_id.lower()\n            \n            # Store mapping from lowercase to actual case\n            doc_id_mapping[doc_id_lower] = doc_id\n            \n            # Create mock document content based on type\n            mock_content = create_mock_document_content(doc[\"documentType\"], request, doc)\n            request_documents[req_id_lower][doc_id_lower] = {\n                \"type\": doc[\"documentType\"],\n                \"fileName\": doc[\"fileName\"],\n                \"filePath\": doc[\"filePath\"],\n                \"content\": mock_content,\n                \"actual_document_id\": doc_id  # Store actual case for response\n            }\n    \n    # Convert search parameters to lowercase for comparison\n    request_id_lower = request_id.lower()\n    document_id_lower = document_id.lower()\n    \n    # Check if request exists (case insensitive)\n    if request_id_lower not in request_documents:\n        available_requests = [request_id_mapping[req_id] for req_id in request_documents.keys()]\n        return json.dumps({\n            \"error\": f\"Request ID '{request_id}' not found\",\n            \"available_requests\": available_requests\n        })\n    \n    # Check if document exists for this request (case insensitive)\n    if document_id_lower not in request_documents[request_id_lower]:\n        available_documents = [doc_data[\"actual_document_id\"] for doc_data in request_documents[request_id_lower].values()]\n        return json.dumps({\n            \"error\": f\"Document ID '{document_id}' not found for request '{request_id}'\",\n            \"available_documents\": available_documents\n        })\n    \n    # Return the document content\n    document_data = request_documents[request_id_lower][document_id_lower]\n    actual_request_id = request_id_mapping[request_id_lower]\n    actual_document_id = document_data[\"actual_document_id\"]\n    \n    return json.dumps({\n        \"request_id\": actual_request_id,\n        \"document_id\": actual_document_id,\n        \"document_type\": document_data[\"type\"],\n        \"file_name\": document_data[\"fileName\"],\n        \"content\": document_data[\"content\"]\n    })\n\ndef create_mock_document_content(doc_type: str, request: dict, doc: dict) -> dict:\n    \"\"\"Create realistic mock document content based on document type.\"\"\"\n    \n    base_content = {\n        \"document_id\": doc[\"documentId\"],\n        \"file_path\": doc[\"filePath\"],\n        \"processed_date\": \"2024-12-30\"\n    }\n    \n    if doc_type == \"Orders Document\":\n        return {\n            **base_content,\n            \"orders_type\": \"Permanent Change of Station (PCS)\",\n            \"effective_date\": request[\"requestDetails\"][\"requestedEffectiveDate\"],\n            \"from_location\": \"Previous Base\",\n            \"to_location\": \"New Assignment Location\",\n            \"report_date\": request[\"requestDetails\"][\"requestedEffectiveDate\"]\n        }\n    \n    elif doc_type == \"Proof of Military Service\":\n        return {\n            **base_content,\n            \"service_verification\": True,\n            \"active_duty_status\": \"Active\",\n            \"branch\": \"U.S. Army\",\n            \"rank\": \"Sergeant (E-5)\",\n            \"verification_date\": \"2024-12-30\"\n        }\n    \n    elif doc_type == \"Leave and Earnings Statement\":\n        return {\n            **base_content,\n            \"pay_period\": \"2024-12-01 to 2024-12-31\",\n            \"base_pay\": 3500.00,\n            \"allowances\": 1200.00,\n            \"deductions\": 800.00,\n            \"net_pay\": 3900.00\n        }\n    \n    elif doc_type == \"Proof of Residence\":\n        return {\n            **base_content,\n            \"address_verified\": True,\n            \"lease_start_date\": \"2024-01-01\",\n            \"monthly_rent\": 2500.00,\n            \"landlord_contact\": \"Property Management Company\"\n        }\n    \n    else:\n        return {\n            **base_content,\n            \"content_type\": doc_type,\n            \"status\": \"verified\"\n        } ",
                "global_imports": [],
                "has_cancellation_support": false
              },
              "description": "Create custom tools by wrapping standard Python functions."
            }
          ],
          "metadata": {}
        },
        "description": "Processes document requests and returns specific document content"
      },
      {
        "provider": "autogen_agentchat.agents.AssistantAgent",
        "component_type": "agent",
        "version": 1,
        "component_version": 1,
        "label": "Eligibility Decision",
        "config": {
          "name": "Eligibility_Decision_agent",
          "description": "Determines eligibility based on verified context and docs",
          "model_client": {
            "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
            "config": {
              "model": "gpt-4o-mini"
            },
            "component_type": "model",
            "version": 1,
            "component_version": 1,
            "description": "Chat completion client for OpenAI hosted models.",
            "label": "OpenAIChatCompletionClient"
          },
          "model_context": {
            "provider": "autogen_core.model_context.UnboundedChatCompletionContext",
            "config": {},
            "component_type": "chat_completion_context",
            "version": 1,
            "component_version": 1,
            "description": "An unbounded chat completion context that keeps a view of the all the messages.",
            "label": "UnboundedChatCompletionContext"
          },
          "system_message": "You are the Eligibility Decision Agent responsible for determining benefit eligibility based on industry-standard military/veteran benefit rules.\n\n**ELIGIBILITY FRAMEWORK:**\n\n**1. CORE SERVICE REQUIREMENTS:**\n- **Active Duty**: Currently serving, valid military orders\n- **Veteran**: Honorable discharge required, minimum 24 months service (exceptions for service-connected disabilities)\n- **Reserve/Guard**: Active drilling status, minimum 6 years commitment\n- **Service Verification**: Valid DD-214, orders, or current military ID required\n\n**2. BENEFIT-SPECIFIC ELIGIBILITY RULES:**\n\n**Auto Loan Deferment:**\n- Active duty with PCS orders OR deployment orders\n- Reserve/Guard activated for 180+ days\n- Veterans with documented financial hardship due to service-connected disability\n- Required docs: Orders, loan statements, financial hardship documentation\n- Max deferment: 12 months\n\n**Foreclosure Protection (SCRA):**\n- Active duty with mortgage pre-dating military service OR\n- Active duty with PCS orders affecting ability to sell/rent\n- Reserve/Guard on active duty 30+ days\n- Required docs: Orders, mortgage documents, deployment orders\n- Protection period: Duration of military service + 9 months\n\n**Overdraft Fee Refund:**\n- Active duty members only\n- Fees incurred during deployment or PCS move\n- Must be within 60 days of fee occurrence\n- Required docs: Bank statements, deployment/PCS orders\n- Max refund: $500 per incident\n\n**Credit Card APR Reduction (SCRA):**\n- Active duty with accounts pre-dating military service\n- APR reduction to 6% during active duty\n- Reserve/Guard on orders 30+ days\n- Required docs: Credit statements, military orders, account history\n- Retroactive to start of military service\n\n**3. DISQUALIFYING FACTORS:**\n- Dishonorable discharge\n- Fraudulent documentation\n- Previous benefit abuse/fraud\n- Non-military related financial hardship (for military-specific benefits)\n- Failure to provide required documentation within 30 days\n\n**4. ADDITIONAL CONSIDERATIONS:**\n- **Geographic Requirements**: Some benefits require stateside service\n- **Income Limits**: Financial hardship benefits may have income thresholds\n- **Family Coverage**: Spouse benefits require valid marriage certificate\n- **Emergency Provisions**: Expedited processing for combat deployment\n- **Appeals Process**: All denials subject to 30-day appeal period\n\n**5. DOCUMENTATION MATRIX:**\n- **Identity**: Military ID, DD-214, or current orders\n- **Service Status**: Orders, LES (Leave and Earnings Statement), or command verification\n- **Financial**: Bank statements, loan documents, credit reports\n- **Residence**: Utility bills, lease agreements, PCS orders\n- **Family**: Marriage certificate, dependent ID cards\n\n**DECISION PROCESS:**\n\n1. **Verify Service Status**: Confirm active duty, veteran, or reserve status\n2. **Check Benefit-Specific Rules**: Apply appropriate eligibility criteria\n3. **Document Review**: Ensure all required documentation is present and valid\n4. **Risk Assessment**: Evaluate for fraud indicators or inconsistencies\n5. **Make Decision**: Approve, decline, or request additional information\n\n**RESPONSE FORMATS:**\n\n**For missing documents:**\n```json\n{\n  \"action\": \"REQUEST_PROCESS_DOC\",\n  \"docs\": [\"DOC-001\", \"DOC-002\"],\n  \"reason\": \"Need orders and financial statements to verify eligibility\"\n}\n```\n\n**For final decision (always make a decision with available information):**\nUse plain text format instead of JSON to avoid triggering AutoGen's automatic routing:\n\n## ELIGIBILITY DECISION\n\n**Decision:** APPROVED / DECLINED\n\n**Benefit Type:** [Type of benefit]\n\n**Eligibility Basis:** [Reason for decision]\n\n**Justification:** [Detailed explanation of decision reasoning, including all factors considered]\n\n**Conditions:** [Any conditions or requirements if approved]\n\n**Effective Period:** [Time period for benefit if approved]\n\n**Appeal Rights:** Decision may be appealed within 30 days if circumstances change\n\n**Missing Information:** [Note if any critical information was unavailable]\n\n**CRITICAL**: Do not use REQUEST_USER_INPUT action or JSON responses with \"action\" fields. Always make the best decision possible with available information. Use the plain text format above. The Request Analysis Agent will handle workflow routing.\n\n**QUALITY STANDARDS:**\n- Always cite specific regulation or policy basis\n- Provide clear, actionable feedback for denials\n- Include appeal information for all decisions\n- Document any exceptions or special circumstances\n- Ensure decisions comply with SCRA, MLA, and DoD regulations\n- Make decisions with available information rather than requesting additional input\n\nDo not invoke follow-up steps \u2014 the Orchestrator will handle workflow routing.",
          "reflect_on_tool_use": true,
          "model_client_stream": false,
          "tool_call_summary_format": "{result}",
          "tools": [],
          "metadata": {}
        },
        "description": "Determines eligibility based on verified context and docs"
      },
      {
        "provider": "autogen_agentchat.agents.AssistantAgent",
        "component_type": "agent",
        "version": 1,
        "component_version": 1,
        "label": "Request Analysis Agent",
        "config": {
          "name": "Request_Analysis_agent",
          "description": "Analyzes request details and applies policy rules to decide next orchestration steps",
          "model_client": {
            "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
            "config": {
              "model": "gpt-4o-mini"
            },
            "component_type": "model",
            "version": 1,
            "component_version": 1,
            "description": "Chat completion client for OpenAI hosted models.",
            "label": "OpenAIChatCompletionClient"
          },
          "model_context": {
            "provider": "autogen_core.model_context.HeadAndTailChatCompletionContext",
            "component_type": "chat_completion_context",
            "config": {
              "head_size": 1,
              "tail_size": 3
            },
            "version": 1,
            "component_version": 1,
            "description": "An unbounded chat completion context that keeps a view of the all the messages.",
            "label": "UnboundedChatCompletionContext"
          },
          "system_message": "You are the Request Analysis Agent responsible for analyzing workflow context and routing to the next appropriate agent.\n\n**CRITICAL RULES TO PREVENT LOOPS:**\n\n1. **NEVER CALL `get_request_details` TWICE**: If you have already retrieved request details in this conversation, DO NOT call `get_request_details` again. Use the data you already have.\n\n2. **CHECK CONVERSATION HISTORY FIRST**: Before calling any tools, review recent messages to see if you or other agents have already obtained the needed information.\n\n3. **ONE TOOL CALL PER TURN**: Only call `get_request_details` if:\n   - User provides a new request ID AND\n   - You have NOT already retrieved details for this request ID AND\n   - No other agent has provided request details in recent conversation\n\n**ROUTING PROCESS:**\n\n1. **SCAN RECENT MESSAGES**: Check if request details are already available in conversation\n2. **CONDITIONAL RETRIEVAL**: Only call `get_request_details` if absolutely necessary (see rules above)\n3. **DETERMINE NEXT AGENT**: Apply workflow rules based on current state\n4. **GENERATE RESPONSE**: Always provide response in the specified JSON format below\n\n**WORKFLOW RULES:**\n\n1. **Initial Step**: If this is the start of a new request \u2192 Customer_Verification_agent\n\n2. **After Customer Verification**: Always \u2192 Eligibility_Decision_agent\n\n3. **Document Request Handling**: If any agent requests documents (REQUEST_PROCESS_DOC) \u2192 Document_Processing_agent\n\n4. **After Eligibility Decision**: If you see Eligibility_Decision_agent has provided a decision (containing \"Decision: APPROVED\" or \"Decision: DECLINED\" or \"## ELIGIBILITY DECISION\") \u2192 ALWAYS route to Judge_agent\n\n5. **After Judge Agent**: Always \u2192 UserProxyAgent\n\n6. **After UserProxyAgent**: If user agrees with decision \u2192 Benefit_Execution_agent\n\n7. **After Benefit Execution**: Always \u2192 TERMINATE\n\n**REQUIRED RESPONSE FORMAT:**\nAlways respond with this exact JSON structure:\n\n```json\n{\n  \"next_agent\": \"Customer_Verification_agent\",\n  \"request_details\": {\n    \"requestId\": \"REQ-001\",\n    \"requestor\": {...},\n    \"requestDetails\": {...}\n  },\n  \"context_summary\": \"Brief summary of workflow progress\",\n  \"instructions\": \"Detailed instructions for next agent\"\n}\n```\n\n**AGENT NAME MAPPING:**\n- Customer Verification \u2192 \"Customer_Verification_agent\"\n- Document Processing \u2192 \"Document_Processing_agent\"\n- Eligibility Decision \u2192 \"Eligibility_Decision_agent\"\n- Judge Agent \u2192 \"Judge_agent\"\n- User Input \u2192 \"UserProxyAgent\"\n- Benefit Execution \u2192 \"Benefit_Execution_agent\"\n\n**EFFICIENCY PRINCIPLE:**\nPrefer using information already available in the conversation over making new tool calls. Only retrieve request details if they are truly missing from the current context.",
          "reflect_on_tool_use": true,
          "model_client_stream": false,
          "tool_call_summary_format": "{result}",
          "tools": [
            {
              "provider": "autogen_core.tools.FunctionTool",
              "component_type": "tool",
              "version": 1,
              "component_version": 1,
              "description": "Retrieves complete request details using a request ID.",
              "label": "Get Request Details Tool",
              "config": {
                "name": "get_request_details",
                "description": "Retrieves the complete details of a benefit request using the request ID.",
                "source_code": "import json\n\ndef get_request_details(request_id: str) -> str:\n    \"\"\"\n    Retrieves the complete details of a benefit request using the request ID.\n    \n    Args:\n        request_id (str): The ID of the benefit request to retrieve (e.g., \"REQ-001\")\n        \n    Returns:\n        str: A JSON string containing the complete request details including requestor info, \n             benefit type, description, effective date, and associated documents\n    \"\"\"\n    # This will be replaced with actual mock data by combine_tools.py\n    MOCK_REQUESTS_DATA = [{'requestId': 'REQ-001', 'timestamp': '2025-06-30T21:50:27.064084Z', 'customerId': '', 'requestor': {'fullName': 'Ashlee Thompson', 'dateOfBirth': '1983-01-21', 'ssnLast4': '7583', 'email': 'kayla59@matthews.biz', 'phone': '824.057.7423x6297', 'address': {'street': '5896 Daniel Fort', 'city': 'Joshuahaven', 'state': 'AZ', 'zip': '94396'}, 'militaryStatus': 'Veteran', 'branch': 'Coast Guard', 'serviceStartDate': '2020-01-01', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Auto Loan Deferment', 'description': 'Range next light half ok there.', 'requestedEffectiveDate': '2025-08-06'}, 'documents': [{'documentId': 'DOC-001', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-001.pdf', 'filePath': '/documents/orders_document_DOC-001.pdf'}, {'documentId': 'DOC-002', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-002.pdf', 'filePath': '/documents/proof_of_military_service_DOC-002.pdf'}]}, {'requestId': 'REQ-002', 'timestamp': '2025-06-30T21:50:27.065405Z', 'customerId': '', 'requestor': {'fullName': 'Rachel Glover', 'dateOfBirth': '1994-09-19', 'ssnLast4': '8365', 'email': 'mendozanicholas@yahoo.com', 'phone': '824.447.7428x7274', 'address': {'street': '3595 Elizabeth Passage', 'city': 'South Mariaton', 'state': 'OH', 'zip': '59096'}, 'militaryStatus': 'Reserve', 'branch': 'Army', 'serviceStartDate': '2018-10-09', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Foreclosure Protection', 'description': 'Pass weight culture.', 'requestedEffectiveDate': '2025-07-14'}, 'documents': [{'documentId': 'DOC-003', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-003.pdf', 'filePath': '/documents/proof_of_military_service_DOC-003.pdf'}, {'documentId': 'DOC-004', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-004.pdf', 'filePath': '/documents/orders_document_DOC-004.pdf'}]}, {'requestId': 'REQ-003', 'timestamp': '2025-06-30T21:50:27.066422Z', 'customerId': '', 'requestor': {'fullName': 'Heather Mason', 'dateOfBirth': '1998-05-15', 'ssnLast4': '4674', 'email': 'stephen16@gmail.com', 'phone': '079-991-8795', 'address': {'street': '38232 Joseph Fords', 'city': 'Lake Todd', 'state': 'AZ', 'zip': '58315'}, 'militaryStatus': 'Active Duty', 'branch': 'Army', 'serviceStartDate': '2020-05-17', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Overdraft Fee Refund', 'description': 'Safe become north nice Mr quite enough.', 'requestedEffectiveDate': '2025-08-17'}, 'documents': [{'documentId': 'DOC-005', 'documentType': 'Leave and Earnings Statement', 'fileName': 'leave_and_earnings_statement_DOC-005.pdf', 'filePath': '/documents/leave_and_earnings_statement_DOC-005.pdf'}, {'documentId': 'DOC-006', 'documentType': 'Proof of Residence', 'fileName': 'proof_of_residence_DOC-006.pdf', 'filePath': '/documents/proof_of_residence_DOC-006.pdf'}]}, {'requestId': 'REQ-004', 'timestamp': '2025-06-30T21:50:27.068256Z', 'customerId': '', 'requestor': {'fullName': 'Corey Lucas', 'dateOfBirth': '1993-01-11', 'ssnLast4': '5829', 'email': 'wilsonlisa@williams.info', 'phone': '+1-589-467-8480x428', 'address': {'street': '5266 Shaw Locks', 'city': 'East Melissamouth', 'state': 'MO', 'zip': '35641'}, 'militaryStatus': 'Reserve', 'branch': 'Army', 'serviceStartDate': '2015-03-03', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Foreclosure Protection', 'description': 'Light international so today opportunity.', 'requestedEffectiveDate': '2025-08-19'}, 'documents': [{'documentId': 'DOC-007', 'documentType': 'Proof of Military Service', 'fileName': 'proof_of_military_service_DOC-007.pdf', 'filePath': '/documents/proof_of_military_service_DOC-007.pdf'}, {'documentId': 'DOC-008', 'documentType': 'Proof of Residence', 'fileName': 'proof_of_residence_DOC-008.pdf', 'filePath': '/documents/proof_of_residence_DOC-008.pdf'}]}, {'requestId': 'REQ-005', 'timestamp': '2025-06-30T21:50:27.070075Z', 'customerId': '', 'requestor': {'fullName': 'Kristopher Phillips', 'dateOfBirth': '1988-03-04', 'ssnLast4': '7025', 'email': 'kellywagner@travis.com', 'phone': '001-161-483-3768x76063', 'address': {'street': '8009 Snyder Radial', 'city': 'East Christyville', 'state': 'KY', 'zip': '48228'}, 'militaryStatus': 'Active Duty', 'branch': 'Marines', 'serviceStartDate': '2014-07-31', 'serviceEndDate': None}, 'requestDetails': {'benefitType': 'Credit Card APR Reduction', 'description': 'Never site national price good design.', 'requestedEffectiveDate': '2025-07-30'}, 'documents': [{'documentId': 'DOC-009', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-009.pdf', 'filePath': '/documents/orders_document_DOC-009.pdf'}, {'documentId': 'DOC-010', 'documentType': 'Orders Document', 'fileName': 'orders_document_DOC-010.pdf', 'filePath': '/documents/orders_document_DOC-010.pdf'}]}]\n    \n    # Search for the request with the matching ID (case insensitive)\n    for request in MOCK_REQUESTS_DATA:\n        stored_id = request.get(\"requestId\", \"\")\n        if stored_id.lower() == request_id.lower():\n            return json.dumps({\n                \"success\": True,\n                \"request\": request\n            }, indent=2)\n    \n    # Request not found\n    available_request_ids = [req.get(\"requestId\", \"Unknown\") for req in MOCK_REQUESTS_DATA]\n    return json.dumps({\n        \"success\": False,\n        \"error\": f\"Request ID '{request_id}' not found\",\n        \"available_request_ids\": available_request_ids\n    }, indent=2)\n\ndef generate_routing_output(next_agent: str, request_details: dict = None, context_summary: str = \"\", instructions: str = \"\") -> str:\n    \"\"\"\n    Generates a structured routing output that the orchestrator can reliably parse.\n    \n    Args:\n        next_agent (str): The name of the next agent to route to\n        request_details (dict): Optional request details to include\n        context_summary (str): Summary of current workflow progress\n        instructions (str): Specific instructions for the next agent\n        \n    Returns:\n        str: Formatted routing output with clear agent selection\n    \"\"\"\n    output = []\n    \n    # Very prominent routing section that orchestrator looks for\n    output.append(\"=== ORCHESTRATOR ROUTING ===\")\n    output.append(f\"NEXT_AGENT: {next_agent}\")\n    output.append(\"=== END ROUTING ===\")\n    output.append(\"\")\n    \n    # Request analysis section\n    if request_details:\n        output.append(\"## REQUEST ANALYSIS\")\n        output.append(f\"**Request ID:** {request_details.get('requestId', 'N/A')}\")\n        output.append(f\"**Requestor:** {request_details.get('requestor', {}).get('fullName', 'N/A')}\")\n        output.append(f\"**Benefit Type:** {request_details.get('requestDetails', {}).get('benefitType', 'N/A')}\")\n        output.append(f\"**Military Status:** {request_details.get('requestor', {}).get('militaryStatus', 'N/A')}\")\n        output.append(f\"**Service Branch:** {request_details.get('requestor', {}).get('branch', 'N/A')}\")\n        output.append(\"\")\n    \n    # Next agent section (backup for the orchestrator)\n    output.append(\"## NEXT AGENT\")\n    output.append(f\"**Agent:** {next_agent}\")\n    output.append(\"\")\n    \n    # Instructions for next agent\n    if instructions:\n        output.append(\"## INSTRUCTIONS FOR NEXT AGENT\")\n        output.append(instructions)\n        output.append(\"\")\n    \n    # Context summary\n    if context_summary:\n        output.append(\"## CONTEXT SUMMARY\")\n        output.append(context_summary)\n        output.append(\"\")\n    \n    return \"\\n\".join(output) ",
                "global_imports": [],
                "has_cancellation_support": false
              }
            }
          ],
          "metadata": {}
        },
        "description": "Analyzes request details and applies policy rules to decide next orchestration steps"
      },
      {
        "provider": "autogen_agentchat.agents.AssistantAgent",
        "component_type": "agent",
        "version": 1,
        "component_version": 1,
        "label": "Benefit Execution",
        "config": {
          "name": "Benefit_Execution_agent",
          "description": "Executes benefit after approval",
          "model_client": {
            "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
            "config": {
              "model": "gpt-4o-mini"
            },
            "component_type": "model",
            "version": 1,
            "component_version": 1,
            "description": "Chat completion client for OpenAI hosted models.",
            "label": "OpenAIChatCompletionClient"
          },
          "model_context": {
            "provider": "autogen_core.model_context.UnboundedChatCompletionContext",
            "config": {},
            "component_type": "chat_completion_context",
            "version": 1,
            "component_version": 1,
            "description": "An unbounded chat completion context that keeps a view of the all the messages.",
            "label": "UnboundedChatCompletionContext"
          },
          "system_message": "You are the Benefit Execution Agent.\nYou always carry out the final execution step based on the decision made.\n\n**For APPROVED benefits:**\n- Execute the benefit enrollment/activation\n- Generate confirmation details\n- Notify customer of successful activation\n\n**For DECLINED benefits:**\n- Generate decline notification\n- Provide clear explanation of decision\n- Include any appeal/reapplication information\n\nReturn structured response:\n{\n  \"execution_type\": \"benefit_activation\" | \"decline_notification\",\n  \"status\": \"success\" | \"failure\",\n  \"customer_message\": \"...\",\n  \"details\": \"...\"\n}",
          "reflect_on_tool_use": true,
          "model_client_stream": false,
          "tool_call_summary_format": "{result}",
          "tools": [],
          "metadata": {}
        },
        "description": "Executes benefit after approval"
      },
      {
        "provider": "autogen_agentchat.agents.AssistantAgent",
        "component_type": "agent",
        "version": 1,
        "component_version": 1,
        "label": "Judge Agent",
        "config": {
          "name": "Judge_agent",
          "description": "Monitors orchestration correctness and suggests human review",
          "model_client": {
            "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
            "config": {
              "model": "gpt-4o-mini"
            },
            "component_type": "model",
            "version": 1,
            "component_version": 1,
            "description": "Chat completion client for OpenAI hosted models.",
            "label": "OpenAIChatCompletionClient"
          },
          "model_context": {
            "provider": "autogen_core.model_context.UnboundedChatCompletionContext",
            "config": {},
            "component_type": "chat_completion_context",
            "version": 1,
            "component_version": 1,
            "description": "An unbounded chat completion context that keeps a view of the all the messages.",
            "label": "UnboundedChatCompletionContext"
          },
          "system_message": "You are the Judge Agent.\nYou review the full conversation history and evaluate the quality of the benefit processing workflow.\n\n**EXPECTED WORKFLOW RULES (from Request Analysis Agent):**\n1. **Initial Step**: Customer_Verification_agent\n2. **After Customer Verification**: Always \u2192 Eligibility_Decision_agent\n3. **Document Request Handling (applies globally)**:\n   - If any agent requests documents (REQUEST_PROCESS_DOC) \u2192 Document_Processing_agent\n   - After Document Processing completes \u2192 return to the agent that originally requested documents\n4. **After Eligibility Decision**: Always \u2192 Judge_agent\n5. **After Judge Agent**: Always \u2192 UserProxyAgent\n6. **After UserProxyAgent (User Response)**:\n   - If user agrees with decision \u2192 Benefit_Execution_agent\n   - If user disagrees, collect user's updated decision \u2192 Benefit_Execution_agent (using the user's decision)\n7. **After Benefit Execution**: Always \u2192 TERMINATE\n\n**Your Task:**\n1. Review the complete conversation from start to current point\n2. Evaluate workflow compliance with the above rules\n3. Assess customer verification, document processing, eligibility decision quality\n4. Check if all required steps were properly completed\n5. Verify agents followed proper sequence and procedures\n\n**Return structured feedback:**\n{\n  \"quality_score\": 0-7,\n  \"workflow_compliance\": \"COMPLIANT\" | \"MINOR_DEVIATION\" | \"MAJOR_DEVIATION\",\n  \"evaluation_summary\": \"Overall assessment of processing quality\",\n  \"strengths\": [\"What was done well\"],\n  \"concerns\": [\"Any issues, gaps, or rule violations identified\"],\n  \"recommendation\": \"PROCEED\" | \"USER_REVIEW_REQUIRED\"\n}\n\n**Scoring Guide:**\n- 7: Perfect execution, all steps complete, full compliance\n- 6: Good execution, minor issues or deviations\n- 5-4: Adequate but notable concerns or rule deviations\n- 3-0: Significant issues or major rule violations requiring review\n\n**If score < 6, set recommendation to USER_REVIEW_REQUIRED**",
          "reflect_on_tool_use": true,
          "model_client_stream": false,
          "tool_call_summary_format": "{result}",
          "tools": [],
          "metadata": {}
        },
        "description": "Monitors orchestration correctness and suggests human review"
      },
      {
        "provider": "autogen_agentchat.agents.UserProxyAgent",
        "component_type": "agent",
        "version": 1,
        "component_version": 1,
        "label": "UserProxyAgent",
        "config": {
          "name": "user_proxy",
          "description": "Handles user questions, uploads, and final approval",
          "model_client_stream": false,
          "reflect_on_tool_use": false,
          "tool_call_summary_format": "{result}",
          "metadata": {}
        },
        "description": "Handles user questions, uploads, and final approval"
      }
    ],
    "model_client": {
      "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
      "component_type": "model",
      "version": 1,
      "component_version": 1,
      "config": {
        "model": "gpt-4o-mini"
      }
    },
    "model_context": {
      "provider": "autogen_core.model_context.HeadAndTailChatCompletionContext",
      "component_type": "chat_completion_context",
      "config": {
        "head_size": 1,
        "tail_size": 2
      }
    },
    "allow_repeated_speaker": false,
    "termination_condition": {
      "provider": "autogen_agentchat.base.OrTerminationCondition",
      "component_type": "termination",
      "version": 1,
      "component_version": 1,
      "config": {
        "conditions": [
          {
            "provider": "autogen_agentchat.conditions.MaxMessageTermination",
            "component_type": "termination",
            "version": 1,
            "component_version": 1,
            "config": {
              "max_messages": 200
            }
          },
          {
            "provider": "autogen_agentchat.conditions.TextMentionTermination",
            "component_type": "termination",
            "version": 1,
            "component_version": 1,
            "config": {
              "text": "TERMINATE"
            }
          }
        ]
      }
    },
    "selector_prompt": "STEP 1: Look at the conversation below and find the VERY LAST speaker (scan from bottom up, find the final agent name before a colon).\n\nSTEP 2: Apply these rules:\n- If the final speaker was NOT 'Request_Analysis_agent' \u2192 return 'Request_Analysis_agent'\n- If the final speaker WAS 'Request_Analysis_agent' \u2192 look for 'next_agent' in their JSON response and return that agent name\n\n<CONVERSATION_HISTORY>\n{history}\n</CONVERSATION_HISTORY>\n\nRead the above history and find the final speaker. Apply the rules. Return ONLY the agent name:",
    "max_selector_attempts": 3,
    "emit_team_events": false,
    "model_client_streaming": false
  }
}